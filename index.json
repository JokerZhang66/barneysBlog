[{"categories":["hugo"],"content":"展示博客主题的相关功能 1.播放bilibili视频 \r 2.播放音乐 原网址： https://music.163.com/#/playlist?id=162024453 3.mapbox 4.插入图片 测试图片\"\r测试图片\r 图片2\"\r图片2\r 5.插入链接 主页地址 6.添加横幅 注意\r\r一个 注意 横幅\r\r 摘要\r\r一个 摘要 横幅\r\r 信息\r\r一个 信息 横幅\r\r 技巧\r\r一个 技巧 横幅\r\r 成功\r\r一个 成功 横幅\r\r 问题\r\r一个 问题 横幅\r\r 警告\r\r一个 警告 横幅\r\r 失败\r\r一个 失败 横幅\r\r 危险\r\r一个 危险 横幅\r\r Bug\r\r一个 Bug 横幅\r\r 示例\r\r一个 示例 横幅\r\r 引用\r\r一个 引用 横幅\r\r 7.插入Youtube视频 8.Latex公式 下面是公式块： $$ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi $$ 这是一个行内公式：$ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi $ 9.pdf文件内嵌 套用下面的模板，填入pdf的外链即可 \u003cobject data=\"https://xxxx.pdf\" type=\"application/pdf\" width=\"100%\" height= \"700px\"\u003e \u003cembed src=\"https://xxxx.pdf\"\u003e \u003cp\u003eThis browser does not support PDFs. Please download the PDF to view it: \u003ca href=\"https://xxxx.pdf\"\u003eDownload PDF\u003c/a\u003e.\u003c/p\u003e \u003c/embed\u003e \u003c/object\u003e pdf展示效果 This browser does not support PDFs. Please download the PDF to view it: Download PDF. \r\r 10.博客功能展示 在要置顶的文章的Front matter中添加weight: 1(按weight值从小到大排序) 11.新增视频shortcodes 爱奇艺和搜狐不能直接用播放页面地址的视频id，使用页面的分享按钮获取完整iframe地址 爱奇艺是tvid部分，搜狐是bid部分。 {{\u003c qqvideo r0029muuhfj \u003e}} {{\u003c youku XMzk1NjM1MjAw \u003e}} {{\u003c sohu 90742150 \u003e}} {{\u003c acfun ac14349183 \u003e}} ","date":"2021-06-30","objectID":"/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA/:0:0","series":null,"tags":["blog","hugo"],"title":"博客功能展示","uri":"/%E5%8D%9A%E5%AE%A2%E5%8A%9F%E8%83%BD%E5%B1%95%E7%A4%BA/#"},{"categories":["教程篇"],"content":"安装Nginx sudo apt-get update sudo apt-get install nginx ","date":"2022-03-17","objectID":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/:0:1","series":null,"tags":["Nginx"],"title":"Nginx安装和卸载","uri":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/#安装nginx"},{"categories":["教程篇"],"content":"卸载Nginx sudo apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。 sudo apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。 sudo apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。 sudo apt-get remove nginx-full nginx-common #卸载删除两个主要的包。　 ","date":"2022-03-17","objectID":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/:0:2","series":null,"tags":["Nginx"],"title":"Nginx安装和卸载","uri":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/#卸载nginx"},{"categories":["教程篇"],"content":"参考链接引用\r\rUbuntu安装Nginx和正确卸载Nginx Nginx相关\r\r ","date":"2022-03-17","objectID":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/:0:3","series":null,"tags":["Nginx"],"title":"Nginx安装和卸载","uri":"/nginx%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/#参考链接"},{"categories":["Solution"],"content":"问题描述 ","date":"2022-03-17","objectID":"/%E4%BF%AE%E5%A4%8Duptime-kuma%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%94%99%E8%AF%AF/:0:1","series":null,"tags":["docker","Uptime","踩坑"],"title":"修复Uptime Kuma一个小错误","uri":"/%E4%BF%AE%E5%A4%8Duptime-kuma%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%94%99%E8%AF%AF/#问题描述"},{"categories":["Solution"],"content":"解决方案 在location /中添加下列两行: proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; ","date":"2022-03-17","objectID":"/%E4%BF%AE%E5%A4%8Duptime-kuma%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%94%99%E8%AF%AF/:0:2","series":null,"tags":["docker","Uptime","踩坑"],"title":"修复Uptime Kuma一个小错误","uri":"/%E4%BF%AE%E5%A4%8Duptime-kuma%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%94%99%E8%AF%AF/#解决方案"},{"categories":["solution"],"content":"由于安全或者其它原因，我们可能会修改默认的SSH服务端口号，默认情况下，已有的git项目在pull或者push的时候会报错。 现在假设原来的项目的remote设置为git@ip:port/marks/web.git，将服务器SSH默认端口修改为1234后，导致push出错。 有三种解决方式： 一、直接修改URL为ssh://开头 git remote set-url origin ssh://git@ip:1234/marks/web.git 二、 修改本地配置文件,映射一个别名 vi ~/.ssh/config host xxx hostname www.xxx.com(ip) port 1234 三、克隆仓库的时候直接指定端口 git clone ssh://git@ip:1234/marks/web.git ","date":"2022-03-14","objectID":"/%E4%BF%AE%E6%94%B9%E4%BA%86ssh%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit/:0:0","series":null,"tags":["ssh","服务器"],"title":"修改了ssh默认端口如何配置git","uri":"/%E4%BF%AE%E6%94%B9%E4%BA%86ssh%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit/#"},{"categories":["编程语言","踩坑记录"],"content":" 1.变量声明 var str string,num int // false var str1 string, str2 string = \"11\",\"22\" // false var str1 string,str2 string,number int = \"11\",\"22\", 2022 // false var str1 , str2 string = \"11\", \"22\" // true var str1 ,str2 , number = \"11\",\"22\", 2022 // true 2.\":=“不能用于已声明的变量 var str string := \"111\" // false var str := \"111\" // false var str str := \"1111\" // false str1 := \"222\" // true 3.”:=“不能在函数体外使用 package main import \"fmt\" str1 ,str2 := \"one\",\"two\" // false func main() { } 4.常量不能使用”:=“声明 const world := \"222\" // false 5.fallthrough语句 go语言中switch匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码 s := \"abcd\" switch s[0] { case 'a': fmt.Println(\"The character is a\") fallthrough case 'b': fmt.Println(\"The character is b\") fallthrough case 'c': fmt.Println(\"The character is c\") fallthrough case 'd': fmt.Println(\"The character is d\") fallthrough default: fmt.Println(\"default case\") } 输出结果: The character is a The character is b The character is c The character is d default case 把s[0]改为s[1]输出： The character is b The character is c The character is d default case 没有条件的 switch 同 switch true 一样，也可以表述if-then-else switch { case true: fmt.Println(\"true\") fallthrough case false: fmt.Println(\"false\") // 上一个case使用了fallthrough,会强制执行本case default: fmt.Println(\"default case\") } 输出结果： true false 6.切片相当于数组的引用，修改切片相当于修改原数组 slice[i:j:k]其中 i 表示从 slice 的第几个元素开始切，j控制切片的长度(j-i)，k 控制切片的容量(k-i)，如果没有给定 k，则表示切到底层数组的最尾部 package main import \"fmt\" func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // 6 6 [2,3,5,7,11,13] // 截取切片使其长度为 0 s = s[:0] printSlice(s) // 0 6 [] // 拓展其长度 s = s[:4] printSlice(s) // 4 6 [2 3 5 7] // 舍弃前两个值 s = s[2:] printSlice(s) // 2 4 [5 7] s = s[:2] printSlice(s) // 2 4 [5 7] s = s[2:4] printSlice(s) // 2 4 [11 13] } func printSlice(s []int) { fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s) } 输出内容: len=6 cap=6 [2 3 5 7 11 13] len=0 cap=6 [] len=4 cap=6 [2 3 5 7] len=2 cap=4 [5 7] len=2 cap=4 [5 7] len=2 cap=2 [11 13] 7.切片的append()函数会智能地处理底层数组的容量增长 可能容量和长度会出现不一致 package main import \"fmt\" func main() { var s []int printSlice(s) // 添加一个空切片 s = append(s, 0) printSlice(s) // 这个切片会按需增长 s = append(s, 1) printSlice(s) // 可以一次性添加多个元素 s = append(s, 2, 3, 6, 7) // 容量变成6了不是5 printSlice(s) } func printSlice(s []int) { fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s) } 8.映射的使用 package main import \"fmt\" type Vertex struct { Lat, Long float64 } var t1, t2 map[string]Vertex // 声明 func main() { t1 = make(map[string]Vertex) t2 = make(map[string]Vertex) t1[\"hello\"] = Vertex{ // 初始化 101.33, 45.99, } t2[\"xxx\"] = Vertex{ 1055.366, 5.66, } fmt.Println(t1) fmt.Println(t2) m := map[string]Vertex{\"hello\": {102.00, 1.30}} // 初始化 fmt.Println(m) p := map[int]string{1: \"hello\", 2: \"happy\"} p[0] = \"hello\" p[1] = \"world\" // 插入 fmt.Println(p) n := map[int]string{} n[0] = \"happy\" fmt.Println(n) for key, value := range p { fmt.Printf(\"key = %v , value = %v\\n\", key, value) } delete(p, 0) // 删除 p[3] = \"ok\" // 更新 for key, value := range p { fmt.Printf(\"key = %v , value = %v\\n\", key, value) } value,exist := p[0] // 查看值是否还在 fmt.Printf(\"p[0] = %+v exist? %v\",value,exist) } 输出结果： map[hello:{101.33 45.99}] map[xxx:{1055.366 5.66}] map[hello:{102 1.3}] map[0:hello 1:world 2:happy] map[0:happy] key = 1 , value = world key = 2 , value = happy key = 0 , value = hello key = 3 , value = ok key = 1 , value = world key = 2 , value = happy p[0] == exist? false 10.关于i++，++i go语言中i++作为一条语句，和c语言中作为表达式使用有很大不同 j := i++ // syntax error: unexpected ++ at end of statement fmt.Println(i++) // syntax error: unexpected ++, expecting comma or ) ++i // syntax error: unexpected ++, expecting } ","date":"2022-03-08","objectID":"/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E8%B8%A9%E5%9D%91/:0:0","series":null,"tags":["go","踩坑"],"title":"Go语言语法踩坑","uri":"/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95%E8%B8%A9%E5%9D%91/#"},{"categories":["服务器","solution"],"content":"1.查看mysql依赖 dpkg --list|grep mysql 2.卸载 mysql-common sudo apt-get remove mysql-common 3.卸载mysql-server-8.0 sudo apt-get autoremove --purge mysql-server-8.0 4.清除残留数据 dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P 5.再次查看MySQL的剩余依赖项: dpkg --list|grep mysql (这里一般就没有输出了，如果有执行下一步) 6.继续删除剩余依赖项 sudo apt-get autoremove --purge mysql-apt-config 7.删除/etc/mysql和/var/lib/mysql文件夹 sudo rm -rf /etc/mysql /var/lib/mysql 引用\r\r参考:Ubuntu20.04 安装和卸载MySQL8\r\r ","date":"2022-03-08","objectID":"/ubuntu%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDmysql8/:0:0","series":null,"tags":["Ubuntu","mysql"],"title":"Ubuntu20.04彻底卸载mysql8.0","uri":"/ubuntu%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDmysql8/#"},{"categories":["服务器"],"content":"1.docker仓库搜索mysql docker search mysql \r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:1","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#1docker仓库搜索mysql"},{"categories":["服务器"],"content":"2.docker仓库拉取mysql8.0镜像 docker pull mysql:8.0 docker pull mysql #拉取最新版本的mysql ","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:2","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#2docker仓库拉取mysql80镜像"},{"categories":["服务器"],"content":"3.查看本地镜像是否安装成功 docker images mysql:8.0 \r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:3","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#3查看本地镜像是否安装成功"},{"categories":["服务器"],"content":"4.安装运行mysql8.0容器 docker run -p 3307:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:8.0 -p 将本地主机的端口(3307)映射到docker容器端口(3306) –name 容器名称 -e 配置信息，root用户原始密码为root -d 镜像名称 注意\r\r记得去服务器防火墙放行3307端口\r\r ","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:4","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#4安装运行mysql80容器"},{"categories":["服务器"],"content":"5.查看mysql8.0容器运行情况 docker ps \r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:5","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#5查看mysql80容器运行情况"},{"categories":["服务器"],"content":"6.docker登录mysql docker exec -it mysql bash mysql -uroot -p \r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:6","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#6docker登录mysql"},{"categories":["服务器"],"content":"7.使用客户端连接工具(navicat)远程登录mysql\r会出现下面的2059错误 \r报错：navicat不支持caching_sha_password加密方式 原因：mysql8.0使用新的密码加密方式：caching_sha_password 解决方式：修改成旧的加密方式（mysql_native_password），并重置密码 操作如下: usemysql;selecthost,user,pluginfromuser;alteruser'root'@'%'identifiedwithmysql_native_passwordby'root'; \r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:7","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#7使用客户端连接工具navicat远程登录mysql"},{"categories":["服务器"],"content":"8.重新登录成功\r","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:8","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#8重新登录成功"},{"categories":["服务器"],"content":"9.设置mysql容器开机自启动--restart=always后跟的是容器名称 docker update --restart=always mysql ","date":"2022-03-07","objectID":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/:0:9","series":null,"tags":["mysql","docker","Ubuntu"],"title":"Ubuntu上使用docker安装mysql","uri":"/ubuntu%E4%B8%8A%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql/#9设置mysql容器开机自启动"},{"categories":["solution"],"content":"1.找到themes\\LoveIt\\layouts\\posts\\single.html文件,在{{- $params := .Scratch.Get \"params\" -}}的下一行添加下列内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} 2.之后只要在文章的头部加上password属性即可进行加密，只有输入了正确密码才能打开文章，否则会回退到之前的页面。用法如下： --- title: 随笔 password: test --- ","date":"2022-02-23","objectID":"/hugo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD/:0:0","series":null,"tags":["hugo","blog"],"title":"Hugo添加文章加密功能","uri":"/hugo%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86%E5%8A%9F%E8%83%BD/#"},{"categories":["solution"],"content":"1.将themes\\LoveIt\\layouts\\partials\\header.html修改为下列内容: {{- /* Desktop header */ -}} \u003cheader class=\"desktop\" id=\"header-desktop\"\u003e \u003cdiv class=\"header-wrapper\"\u003e \u003cdiv class=\"header-title\"\u003e \u003ca href=\"{{ .Site.Home.RelPermalink }}\" title=\"{{ .Site.Title }}\"\u003e {{- with .Site.Params.header.title -}} {{- with .logo -}} {{- dict \"Src\" . \"Class\" \"logo\" | partial \"plugin/image.html\" -}} {{- end -}} {{- with .pre -}} \u003cspan class=\"header-title-pre\"\u003e{{ . | safeHTML }}\u003c/span\u003e {{- end -}} {{- if .typeit -}} {{- $id := dict \"Content\" .name \"Scratch\" $.Scratch | partial \"function/id.html\" -}} \u003cspan id=\"{{ $id }}\" class=\"typeit\"\u003e\u003c/span\u003e {{- dict $id (slice $id) | dict \"typeitMap\" | merge ($.Scratch.Get \"this\") | $.Scratch.Set \"this\" -}} {{- else -}} {{- .name -}} {{- end -}} {{- with .post -}} \u003cspan class=\"header-title-post\"\u003e{{ . | safeHTML }}\u003c/span\u003e {{- end -}} {{- else -}} {{- .Site.Title -}} {{- end -}} \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"menu\"\u003e \u003cdiv class=\"menu-inner\"\u003e \u003c!-- {{- range .Site.Menus.main -}} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\" href=\"{{ $url }}\"{{ with .Title }} title=\"{{ . }}\"{{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e {{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}} \u003c/a\u003e {{- end -}} --\u003e {{- range .Site.Menus.main -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown\"\u003e \u003ca {{ if .URL }}href=\"{{ .URL }}\" {{ else }}href=\"javascript:void(0);\" {{ end }} class=\"menu-item menu-more dropbtn\" title=\"{{ .Title }}\" {{ if eq .Post \"_blank\" }}target=\"_blank\" rel=\"noopener\" {{ end }}\u003e {{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \"_blank\" }}{{ .Post | safeHTML -}}{{ end }} \u003c/a\u003e \u003cdiv class=\"menu-more-content dropdown-content\"\u003e {{- range .Children -}} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca href=\"{{ $url }}\" title=\"{{ .Title }}\" {{ if eq .Post \"_blank\" }}target=\"_blank\" rel=\"noopener\" {{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \"_blank\" }}{{ .Post | safeHTML -}}{{ end }}\u003c/a\u003e {{- end -}} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\" href=\"{{ $url }}\" {{ with .Title }} title=\"{{ . }}\" {{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\" {{ end }}\u003e {{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \"_blank\" }}{{ .Post | safeHTML -}}{{ end }} \u003c/a\u003e {{- end -}} {{- end -}} {{- if .Site.Menus.main -}} \u003cspan class=\"menu-item delimiter\"\u003e\u003c/span\u003e {{- end -}} {{- if .Site.IsMultiLingual -}} \u003ca href=\"javascript:void(0);\" class=\"menu-item language\" title=\"{{ T \" selectLanguage\" }}\"\u003e {{- .Language.LanguageName -}} \u003ci class=\"fas fa-chevron-right fa-fw\"\u003e\u003c/i\u003e \u003cselect class=\"language-select\" id=\"language-select-desktop\" onchange=\"location = this.value;\"\u003e {{- if eq .Kind \"404\" -}} {{- /* https://github.com/dillonzq/LoveIt/issues/378 */ -}} {{- range .Sites -}} {{- $link := printf \"%v/404.html\" .LanguagePrefix -}} \u003coption value=\"{{ $link }}\" {{ if eq . $.Site }} selected{{ end }}\u003e {{- .Language.LanguageName -}} \u003c/option\u003e {{- end -}} {{- else -}} {{- range .AllTranslations -}} \u003coption value=\"{{ .RelPermalink }}\" {{ if eq .Lang $.Lang }} selected{{ end }}\u003e {{- .Language.LanguageName -}} \u003c/option\u003e {{- end -}} {{- end -}} \u003c/select\u003e \u003c/a\u003e {{- end -}} {{- if .Site.Params.search.enable -}} \u003cspan class=\"menu-item search\" id=\"search-desktop\"\u003e \u003cinput type=\"text\" placeholder=\"{{ .Site.Params.search.placeholder | default (T `searchPlaceholder`) }}\" id=\"search-input-desktop\"\u003e \u003ca href=\"javascript:void(0);\" class=\"search-button search-toggle\" id=\"search-toggle-desktop\" title=\"{{ T `search` }}\"\u003e \u003ci class=\"fas fa-search fa-fw\"\u003e\u003c/i\u003e \u003c/a\u003e \u003ca href=\"javascript:v","date":"2022-02-23","objectID":"/hugo%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B7%BB%E5%8A%A0%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95/:0:0","series":null,"tags":["hugo","blog"],"title":"Hugo导航栏添加二级菜单","uri":"/hugo%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B7%BB%E5%8A%A0%E4%BA%8C%E7%BA%A7%E8%8F%9C%E5%8D%95/#"},{"categories":["solution"],"content":"1.将config.toml中的KaTeX数学公式支持修改为false [params.page.math] enable = false 2.新建themes\\LoveIt\\layouts\\partials\\math.html文件，添加一下内容 \u003cscript type=\"text/x-mathjax-config\"\u003e MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], displayMath: [['$$','$$'], ['\\[','\\]']], processEscapes: true, processEnvironments: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], TeX: { equationNumbers: { autoNumber: \"AMS\" }, extensions: [\"AMSmath.js\", \"AMSsymbols.js\"] } } }); \u003c/script\u003e \u003cscript type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"\u003e\u003c/script\u003e \u003cstyle\u003e code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u003c/style\u003e \u003cscript\u003e document.addEventListener(\"DOMContentLoaded\", function() { renderMathInElement(document.body, { delimiters: [ {left: \"$$\", right: \"$$\", display: true}, {left: \"$\", right: \"$\", display: false} ] }); }); \u003c/script\u003e 3.在themes\\LoveIt\\layouts\\partials\\header.html中的最后添加下列内容 {{ if or .Params.math .Site.Params.math }} {{ partial \"math.html\" . }} {{ end }} 4.在每篇文章最开始的Front Matter中使用math: true表示启用MathJax公式支持 ","date":"2022-02-23","objectID":"/loveit%E4%B8%BB%E9%A2%98%E6%94%AF%E6%8C%81mathjax/:0:0","series":null,"tags":["hugo","blog"],"title":"LoveIt主题支持MathJax","uri":"/loveit%E4%B8%BB%E9%A2%98%E6%94%AF%E6%8C%81mathjax/#"},{"categories":["环境配置"],"content":"以官方文档为准 安装oh-my-zsh前的准备： A Unix-like operating system: macOS, Linux, BSD. On Windows: WSL2 is preferred, but cygwin or msys also mostly work. Zsh should be installed (v4.3.9 or more recent is fine but we prefer 5.0.8 and newer). If not pre-installed (run zsh --version to confirm), check the following wiki instructions here: Installing ZSH curl or wget should be installed git should be installed (recommended v2.4.11 or higher) ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:0","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#"},{"categories":["环境配置"],"content":"1.Ubuntu安装zsh其他系统自行查看:Installing ZSH sudo apt install zsh ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:1","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#1ubuntu安装zsh"},{"categories":["环境配置"],"content":"2.安装oh-my-zshgithub地址：https://github.com/ohmyzsh/ohmyzsh sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 安装成功\"\r安装成功\r ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:2","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#2安装oh-my-zsh"},{"categories":["环境配置"],"content":"3.修改主题使用vim打开.zshrc配置文件 vim ~/.zshrc 修改主题为ZSH_THEME=\"ys\" 修改主题\"\r修改主题\r 退出zsh，重新进入zsh即可生效 ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:3","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#3修改主题"},{"categories":["环境配置"],"content":"4.安装插件在~/.oh-my-zsh/plugins中可以看到所有自带的插件，将插件名称添加到.zshrc中plugin字段中. 例如： plugins=( git bundler dotenv macos rake rbenv ruby ) 安装第三方插件以安装zsh-autosuggestions举例，插件地址在：https://github.com/zsh-users/zsh-autosuggestions 将该项目直接克隆到plugins文件夹下 cd ~/.oh-my-zsh/plugins git clone git@github.com:zsh-users/zsh-autosuggestions.git 最后将插件名称添加到.zshrc中plugin字段中. plugins=( zsh-autosuggestions ) 退出zsh，重新进入zsh即可生效 ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:4","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#4安装插件"},{"categories":["环境配置"],"content":"4.安装插件在~/.oh-my-zsh/plugins中可以看到所有自带的插件，将插件名称添加到.zshrc中plugin字段中. 例如： plugins=( git bundler dotenv macos rake rbenv ruby ) 安装第三方插件以安装zsh-autosuggestions举例，插件地址在：https://github.com/zsh-users/zsh-autosuggestions 将该项目直接克隆到plugins文件夹下 cd ~/.oh-my-zsh/plugins git clone git@github.com:zsh-users/zsh-autosuggestions.git 最后将插件名称添加到.zshrc中plugin字段中. plugins=( zsh-autosuggestions ) 退出zsh，重新进入zsh即可生效 ","date":"2022-02-15","objectID":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/:0:4","series":null,"tags":["zsh","linux"],"title":"Linux下安装zsh","uri":"/linux%E4%B8%8B%E5%AE%89%E8%A3%85zsh/#安装第三方插件"},{"categories":["memo"],"content":"持续更新中","date":"2022-02-10","objectID":"/memo/","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/"},{"categories":["memo"],"content":"1.hosts文件地址如何修改host文件:点此 C:\\Windows\\System32\\drivers\\etc\\hosts ","date":"2022-02-10","objectID":"/memo/:0:1","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#1hosts文件地址"},{"categories":["memo"],"content":"2.查询网站ip https://www.ipaddress.com/ ","date":"2022-02-10","objectID":"/memo/:0:2","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#2查询网站ip"},{"categories":["memo"],"content":"3.刷新dns缓存(cmd) ipconfig /flushdns ","date":"2022-02-10","objectID":"/memo/:0:3","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#3刷新dns缓存cmd"},{"categories":["memo"],"content":"4.将图片白色背景变为透明在线ps网站: 点此 ","date":"2022-02-10","objectID":"/memo/:0:4","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#4将图片白色背景变为透明"},{"categories":["memo"],"content":"5.查看一个网站的favicon图像 网址/favicon.ico ","date":"2022-02-10","objectID":"/memo/:0:5","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#5查看一个网站的favicon图像"},{"categories":["memo"],"content":"6.关于本主题的公式渲染问题 \\\\ 换行需换成\\\\\\\\ $$ f(n)= \\begin{cases} n/2,\u0026 \\text{if $n$ is even}\\\\ 3n+1,\u0026 \\text{if $n$ is odd} \\end{cases} $$ 需换成下列公式： $$ f(n)= \\begin{cases} n/2,\u0026 \\text{if $n$ is even}\\\\\\\\ 3n+1,\u0026 \\text{if $n$ is odd} \\end{cases} $$ $$ f(n)= \\begin{cases} n/2,\u0026 \\text{if $n$ is even}\\\\ 3n+1,\u0026 \\text{if $n$ is odd} \\end{cases} $$ 第二种解决方案 比如下列这个公式渲染失败： $$ \\lambda=\\left\\{\\begin{array}{ll} \\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \u0026 \\text { if } P \\neq Q \\\\ \\frac{3 x_{1}^{2}+2 a_{2} x_{1}+a_{4}-a_{1} y_{1}}{2 y_{1}+a_{1} x_{1}+a_{3}} \u0026 \\text { if } P=Q \\end{array}\\right. $$ 可以使用\u003cdiv\u003e和\u003cdiv\\\u003e包裹 \u003cdiv\u003e $$ \\lambda=\\left\\{\\begin{array}{ll} \\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \u0026 \\text { if } P \\neq Q \\\\ \\frac{3 x_{1}^{2}+2 a_{2} x_{1}+a_{4}-a_{1} y_{1}}{2 y_{1}+a_{1} x_{1}+a_{3}} \u0026 \\text { if } P=Q \\end{array}\\right. $$ \u003cdiv\\\u003e \r$$\r\\lambda=\\left\\{\\begin{array}{ll} \\frac{y_{2}-y_{1}}{x_{2}-x_{1}} \u0026 \\text { if } P \\neq Q \\\\ \\frac{3 x_{1}^{2}+2 a_{2} x_{1}+a_{4}-a_{1} y_{1}}{2 y_{1}+a_{1} x_{1}+a_{3}} \u0026 \\text { if } P=Q \\end{array}\\right.\r$$\r\r","date":"2022-02-10","objectID":"/memo/:0:6","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#6关于本主题的公式渲染问题"},{"categories":["memo"],"content":"7.自定义友链效果 //边框及鼠标悬停的背景颜色，允许设置渐变色 //支持7种：default、red、green、blue、linear-red、linear-green、linear-blue primary-color=\"default\" //头像动画：rotate(鼠标悬停时旋转，此为默认效果)、auto_rotate_left(左旋转)、auto_rotate_right(右旋转) img-animation=\"rotate\" //边框动画：shadow(阴影，此为默认效果)、borderFlash(边框闪现)、led(跑马灯)、bln(主颜色呼吸灯) border-animation=\"shadow\" ","date":"2022-02-10","objectID":"/memo/:0:7","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#7自定义友链效果"},{"categories":["memo"],"content":"8.新建page页面以备忘录页面举例: 由于博主想要使用上目录，所以不使用这种page形式的友链页面，而是直接创建一篇文章作为友链使用，文件头如下： title: \"备忘录\" date: 2022-02-10T16:19:51+08:00 draft: false toc: true tags: [\"笔记\",\"健忘症\"] categories: [\"memo\"] math: true hiddenFromHomePage: true password: root url: memo featuredImage: https://cdn.jsdelivr.net/gh/CorPython/images@master//img/20220211100004.png 注意url要和config.toml中导航栏中的url一致，如下所示： [[languages.zh-cn.menu.main]] parent = \"navigation\" identifier = \"memo\" pre = \"\" post = \"\" name = \"备忘录\" url = \"/memo/\" title = \"\" weight = 5 ","date":"2022-02-10","objectID":"/memo/:0:8","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#8新建page页面"},{"categories":["memo"],"content":"9.更新修改时间每次更新完文章可在文章头中加入lastMod这一项,如下: --- lastMod: 2022-02-23T20:27:23+08:00 --- ","date":"2022-02-10","objectID":"/memo/:0:9","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#9更新修改时间"},{"categories":["memo"],"content":"10.为LoveIt主题添加更多视频分享shortcodes参考链接:Hugo 篇二：为 LoveIt 主题添加更多视频分享 shortcodes ","date":"2022-02-10","objectID":"/memo/:0:10","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#10为loveit主题添加更多视频分享shortcodes"},{"categories":["memo"],"content":"11.快速入门docsifydocsify快速入门 ","date":"2022-02-10","objectID":"/memo/:0:11","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#11快速入门docsify"},{"categories":["memo"],"content":"12.插入小猪佩奇页面\r","date":"2022-02-10","objectID":"/memo/:0:12","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#12插入小猪佩奇页面"},{"categories":["memo"],"content":"13.导入本地图片将图片放在/static/images/下,图片地址填入/images/xxx.jpg ","date":"2022-02-10","objectID":"/memo/:0:13","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#13导入本地图片"},{"categories":["memo"],"content":"14.宝塔443端口不使用尝试重装nginx服务\r\r","date":"2022-02-10","objectID":"/memo/:0:14","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#14宝塔443端口不使用"},{"categories":["memo"],"content":"15.友链的其他三种选项 //边框及鼠标悬停的背景颜色，允许设置渐变色 //支持7种：default、red、green、blue、linear-red、linear-green、linear-blue primary-color=\"default\" //头像动画：rotate(鼠标悬停时旋转，此为默认效果)、auto_rotate_left(左旋转)、auto_rotate_right(右旋转) img-animation=\"rotate\" //边框动画：shadow(阴影，此为默认效果)、borderFlash(边框闪现)、led(跑马灯)、bln(主颜色呼吸灯) border-animation=\"shadow\" ","date":"2022-02-10","objectID":"/memo/:0:15","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#15友链的其他三种选项"},{"categories":["memo"],"content":"16.使用手动摘要你可能希望将文章前置参数中的description变量的内容作为摘要. 你仍然需要在文章开头添加\u003c!--more--\u003e摘要分割符. 将摘要分隔符之前的内容保留为空(留一个空行). 然后LoveIt主题会将你的文章描述作为摘要. ","date":"2022-02-10","objectID":"/memo/:0:16","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#16使用手动摘要"},{"categories":["memo"],"content":"18.解决一个error git remote add origin git@github.com:xxx.git git branch -M main git push -u origin main ","date":"2022-02-10","objectID":"/memo/:0:17","series":null,"tags":["笔记","健忘症"],"title":"备忘录","uri":"/memo/#18解决一个error"},{"categories":["papers"],"content":"第七篇文献笔记 ","date":"2022-01-25","objectID":"/paper07/:0:0","series":null,"tags":["paper"],"title":"Online Pricing and Trading of Private Data in Correlated Queries","uri":"/paper07/#"},{"categories":["papers"],"content":"原文链接原文pdf下载:https://ieeexplore.ieee.org/document/9477119 ","date":"2022-01-25","objectID":"/paper07/:0:1","series":null,"tags":["paper"],"title":"Online Pricing and Trading of Private Data in Correlated Queries","uri":"/paper07/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2022-01-25","objectID":"/paper07/:0:2","series":null,"tags":["paper"],"title":"Online Pricing and Trading of Private Data in Correlated Queries","uri":"/paper07/#原文截图"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2022-01-25","objectID":"/paper07/:0:3","series":null,"tags":["paper"],"title":"Online Pricing and Trading of Private Data in Correlated Queries","uri":"/paper07/#汇报ppt"},{"categories":["服务器"],"content":"持续更新 ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#"},{"categories":["服务器"],"content":"ssh连接 (powershell 或者 git-bash) ssh 用户名@服务器IP ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:1","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#ssh连接-powershell-或者-git-bash"},{"categories":["服务器"],"content":"jupyter映射到本地将远程(服务器)jupyter(8888)与本地(8889)端口绑定 ssh -f -N -L 8889:localhost:8888 remote_user@remote_host 注意要在自己的服务器上开放8888端口!!!! ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:2","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#jupyter映射到本地"},{"categories":["服务器"],"content":"Ubuntu安装宝塔面板 IP:101.33.213.197 ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:3","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#ubuntu安装宝塔面板"},{"categories":["服务器"],"content":"Ubuntu更新软件 sudo apt update sudo apt upgrade sudo apt --purge autoremove // 删除不必要的依赖 ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:4","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#ubuntu更新软件"},{"categories":["服务器"],"content":"Ubuntu删除Openjdk dpkg-query -W -f='${binary:Package}\\n' | grep -E -e '^(ia32-)?(sun|oracle)-java' -e '^openjdk-' -e '^icedtea' -e '^(default|gcj)-j(re|dk)' -e '^gcj-(.*)-j(re|dk)' -e '^java-common' | xargs sudo apt-get -y remove sudo apt-get -y autoremove dpkg -l | grep ^rc | awk '{print($2)}' | xargs sudo apt-get -y purge ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:5","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#ubuntu删除openjdk"},{"categories":["服务器"],"content":"查看宝塔面板用户和密码 bt default ","date":"2022-01-16","objectID":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:6","series":null,"tags":["腾讯云","linux","Ubuntu"],"title":"服务器配置笔记","uri":"/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/#查看宝塔面板用户和密码"},{"categories":["solution"],"content":"安装及删除nvim sudo apt-get install neovim # 安装 sudo apt remove neovim # 删除 ","date":"2022-01-16","objectID":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:1","series":null,"tags":["nvim","gcc","Ubuntu"],"title":"Nvim补全配置记录","uri":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#安装及删除nvim"},{"categories":["solution"],"content":"安装nodejs及npm sudo apt install nodejs npm nodejs --version # 查看版本 ","date":"2022-01-16","objectID":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:2","series":null,"tags":["nvim","gcc","Ubuntu"],"title":"Nvim补全配置记录","uri":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#安装nodejs及npm"},{"categories":["solution"],"content":"升级nodejs到最新版本(coc.nvim版本要求) sudo npm install n -g sudo n stable nodejs --version # 查看版本 ","date":"2022-01-16","objectID":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:3","series":null,"tags":["nvim","gcc","Ubuntu"],"title":"Nvim补全配置记录","uri":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#升级nodejs到最新版本cocnvim版本要求"},{"categories":["solution"],"content":"安装vim-plug插件管理器 url -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 安装插件进入~/.config/nvim/init.vim输入命令:PlugInstall ","date":"2022-01-16","objectID":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:4","series":null,"tags":["nvim","gcc","Ubuntu"],"title":"Nvim补全配置记录","uri":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#安装vim-plug插件管理器"},{"categories":["solution"],"content":"使用PlugInstall前先更换源注意：如果之前安装过插件，请全部卸载，具体办法为：删除.local/share文件夹下的plugge目录 找到下面这两行 let fmt = get(g:, 'plug_url_format', 'https://git::@github.com/%s.git') \\ '^https://git::@github\\.com', 'https://github.com', '') 依次修改为 let fmt = get(g:, 'plug_url_format', 'https://git::@hub.fastgit.org/%s.git') \\ '^https://git::@hub.fastgit\\.org', 'https://hub.fastgit.org', '') ","date":"2022-01-16","objectID":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/:0:5","series":null,"tags":["nvim","gcc","Ubuntu"],"title":"Nvim补全配置记录","uri":"/nvim%E8%A1%A5%E5%85%A8%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/#使用pluginstall前先更换源"},{"categories":["solution"],"content":"同一个文件夹下编译多个c++项目 文件结构图： CmakeLists.txt文件： cmake_minimum_required(VERSION 3.0) # 如果想换成.c文件，将.cpp换成.c file(GLOB_RECURSE files *.cpp) foreach (file ${files}) string(REGEX REPLACE \".+/(.+)\\\\..*\" \"\\\\1\" exe ${file}) if (${file} MATCHES _.cpp) add_executable(${exe} ${file}) continue() endif () endforeach () # 需要多个文件合作生成一个可执行文件,需要自己添加 add_executable(project01 ./project01/hello.h ./project01/main.cpp) add_executable(project02 ./project02/hello.h ./project02/main.cpp) add_executable(project03 ./project03/hello.h ./project03/main.cpp) add_executable(test ./algorithm/test.cpp) ","date":"2022-01-14","objectID":"/cmake%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/:0:0","series":null,"tags":["Cmake","vscode","c++"],"title":"Cmake编译多个项目","uri":"/cmake%E7%BC%96%E8%AF%91%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE/#"},{"categories":["solution"],"content":"加速下载github上的文件的方式有很多，后面再补充！ ","date":"2022-01-14","objectID":"/github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/:0:0","series":null,"tags":["git","github","代理"],"title":"Github下载加速","uri":"/github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/#"},{"categories":["solution"],"content":"使用代理加速端口号视你的代理软件有所不同！ git config --global http.https://github.com.proxy http://127.0.0.1:1217 git config --global https.https://github.com.proxy https://127.0.0.1:1217 打开~/.gitconfig文件，内容如下： [http \"https://github.com\"] proxy = http://127.0.0.1:1217 [https \"https://github.com\"] proxy = https://127.0.0.1:1217 ","date":"2022-01-14","objectID":"/github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/:0:1","series":null,"tags":["git","github","代理"],"title":"Github下载加速","uri":"/github%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/#使用代理加速"},{"categories":["记录"],"content":"\r","date":"2021-12-22","objectID":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/:0:0","series":null,"tags":["算法","c++","背包问题","Prim算法"],"title":"算法作业","uri":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/#"},{"categories":["记录"],"content":"0-1背包题目描述： 有N件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式： 第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 N行，每行两个整数 vi,wi用空格隔开，分别表示第 i件物品的体积和价值。 输出格式: 输出一个整数，表示最大价值 输入样例： 4 5 1 2 2 4 3 4 4 5 输出样例: 8 代码实现1 思路： 这类背包问题的特点是：每种物品仅有一件，可以选择放或不放。 子问题定义：f[i,v]表示前i件物品放入一个容量为v的背包中的得到的最大价值 状态转移方程为: $$ f[i, v]=\\max ({f[i-1, v],f[i-1, v-v_{i}]+w_{i})} $$ 考虑第i件物品放或者不放的问题，转化为只和前i-1物品相关的问题，如果第i件物品不放入背包，那总价值为$f[i-1, v]$;如果放第i件物品到背包中，也就是相当于把前i-1件物品放入容量为$v-v_{i}$的背包中，总价值为 $f\\left[i-1, v-v_{i}\\right]+w_{i}$. #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; int getMaxValue(int *w,int *v ,int N,int W) { int f[N+1][W+1]; memset(f,0,sizeof(f)); for(int i = 1;i \u003c= N;i++) { for(int j = 0; j \u003c= W; j++) { if (j \u003e= w[i]) f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); else f[i][j] = f[i - 1][j]; } } return f[N][W]; } int main() { int N, W; cin \u003e\u003e N \u003e\u003e W; int w[N+1]{0}; int v[N+1]{0}; for (int i = 1; i \u003c= N; i++) { cin \u003e\u003e w[i] \u003e\u003e v[i]; } cout \u003c\u003c getMaxValue(w,v,N,W) \u003c\u003c endl; return 0; } 时间复杂度：$O(N*W)$ 空间复杂度：$O(N*W)$ 代码实现2(简化为1维DP) 子问题定义：f[j]表示N件物品,背包容量为j的背包中的得到的最大价值 状态转移方程为： $$ f[j]=\\max (f[j], f[j-v[i]]+w[i]) $$ 注意：此时我们在更新f[j]的状态时需要逆序处理，避免前一轮的最优值被污染 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; int getMaxValue(int *w,int *v ,int N,int W) { int f[W+1]; memset(f,0,sizeof(f)); for (int i = 1; i \u003c= N; i++) for (int j = W; j \u003e= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); // 简化为1维DP return f[W]; } int main() { int N, W; cin \u003e\u003e N \u003e\u003e W; int w[N+1]{0}; int v[N+1]{0}; for (int i = 1; i \u003c= N; i++) cin \u003e\u003e v[i] \u003e\u003e w[i]; cout \u003c\u003c getMaxValue(w,v,N,W) \u003c\u003c endl; return 0; } 时间复杂度：$O(N*W)$ 空间复杂度：$O(W)$ 代码实现3(进一步减少额外存储空间) 将代码实现2中的代码进一步简化，不适用数组来存储每件物品的体积和价值而是采用临时变量存储，边输入边处理 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; const int MAX_N = 1010; int f[MAX_N]; int main() { int N, W; cin \u003e\u003e N \u003e\u003e W; for (int i = 1; i \u003c= N; i++) { int v,w; // 输入当前物品的体积和价值 cin \u003e\u003e v \u003e\u003e w; // 边输入边处理 for (int j = W; j \u003e= v; j--) f[j] = max(f[j], f[j - v] + w); } cout \u003c\u003c f[W] \u003c\u003c endl; return 0; } 时间复杂度：$O(N*W)$ 空间复杂度：$O(W)$ ","date":"2021-12-22","objectID":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/:0:1","series":null,"tags":["算法","c++","背包问题","Prim算法"],"title":"算法作业","uri":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/#0-1背包"},{"categories":["记录"],"content":"Prim求无向图的最小生成树题目描述： 给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。 求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible. 给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，顶点数为n=|V|，边数为m=|E|。 输入格式： 第一行包含两个整数 n和 m。 接下来 m行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。 输出格式: 共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。 注:不连通的图没有最小生成树 输入样例1： 4 5 1 2 1 1 3 2 1 4 3 2 3 2 3 4 4 输出样例1: 6 结果说明： 输出路径(构成最小成树的三条边): 4 1 3 1 2 1 输入样例2： 5 4 1 3 2 1 2 4 2 3 3 4 5 2 输出样例2： impossible 结果说明： 非连通图无法构成最小生成树! \r代码实现： #include \u003ciostream\u003e#include \u003ccstring\u003e#include \u003calgorithm\u003eusing namespace std; const int N = 510; int g[N][N];//存储图 int dist[N];//存储各个节点到生成树的距离 int st[N];//节点是否被加入到生成树中 int pre[N];//节点的前驱节点 int n, m;//n 个节点，m 条边 const int INF = 0x3f3f3f3f; // 无穷大 int prim() { memset(dist,0x3f, sizeof(dist));//初始化距离数组为一个很大的数 int res= 0; dist[1] = 0;//从 1 号节点开始生成 for(int i = 0; i \u003c n; i++)//每次循环选出一个点加入到生成树 { int t = -1; for(int j = 1; j \u003c= n; j++) //每个节点一次判断 { if(!st[j] \u0026\u0026 (t == -1 || dist[j] \u003c dist[t]))//如果没有在树中，且到树的距离最短，则选择该点 t = j; } if (i \u0026\u0026 dist[t] == INF) return INF; //无最小生成树 st[t] = 1; //选择该点 res += dist[t]; for(int i = 1; i \u003c= n; i++)//更新生成树外的点到生成树的距离 { if(dist[i] \u003e g[t][i] \u0026\u0026 !st[i])//从t到节点i的距离小于原来距离，则更新。 { dist[i] = g[t][i];//更新距离 pre[i] = t;//从t到i的距离更短，i的前驱变为 t. } } } return res; } void getPath()//输出各个边 { for(int i = n; i \u003e 1; i--)//n 个节点，所以生成树有n-1条边。 { cout \u003c\u003c i \u003c\u003c\" \" \u003c\u003c pre[i] \u003c\u003c \" \"\u003c\u003c endl;// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。 } } int main() { memset(g, 0x3f, sizeof(g));//各个点之间的距离初始化成很大的数 cin \u003e\u003e n \u003e\u003e m;//输入节点数和边数 while(m --) { int a, b, w; cin \u003e\u003e a \u003e\u003e b \u003e\u003e w;//输出边的两个顶点和权重 g[a][b] = g[b][a] = min(g[a][b],w);//存储权重 } int ans = prim(); if (ans == INF) cout \u003c\u003c \"impossible\" \u003c\u003c endl; else cout \u003c\u003c ans \u003c\u003c endl;//求最下生成树 //getPath();//去掉注释可以输出最小生成树的路径 return 0; } 时间复杂度：$O(n^2)$ 空间复杂度：$O(n^2)$ ","date":"2021-12-22","objectID":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/:0:2","series":null,"tags":["算法","c++","背包问题","Prim算法"],"title":"算法作业","uri":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/#prim求无向图的最小生成树"},{"categories":["记录"],"content":"快速排序算法(经典算法)题目描述: 给定你一个长度为 n 的整数数列。 请你使用快速排序对这个数列按照从小到大进行排序。 并将排好序的数列按顺序输出。 输入格式： 输入共两行，第一行包含整数 n 第二行包含 n 个整数（所有整数均在 $1$∼$10^9$ 范围内），表示整个数列。 输出格式: 输出共一行，包含 n个整数，表示排好序的数列。 输入样例： 5 3 1 2 4 5 输出样例： 1 2 3 4 5 数据范围： $$ 1 \\leq n \\leq 100000 $$ 代码实现： #include \u003ciostream\u003eusing namespace std; const int N = 100010; int n,q[N]; void quick_sort(int q[],int l,int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i++; while (q[i] \u003c x); do j--; while (q[j] \u003e x); if (i \u003c j) swap(q[i],q[j]); } quick_sort(q,l,j); quick_sort(q,j+1,r); } int main() { scanf(\"%d\",\u0026n); for (int i = 0; i \u003c n; i++) scanf(\"%d\",\u0026q[i]); quick_sort(q,0,n-1); for (int i = 0; i \u003c n; i++) printf(\"%d \",q[i]); return 0; } ","date":"2021-12-22","objectID":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/:0:3","series":null,"tags":["算法","c++","背包问题","Prim算法"],"title":"算法作业","uri":"/%E7%AE%97%E6%B3%95%E4%BD%9C%E4%B8%9A/#快速排序算法经典算法"},{"categories":["教程篇"],"content":"1.Vscode集成git-Bash终端使用ctrl + shift + p打开设置,再点开右上角的settings.json,填入下列配置 \r \"terminal.integrated.profiles.windows\": { \"Git-Bash\": { \"path\": \"F:\\\\Git\\\\bin\\\\bash.exe\" } } 设置默认终端可以使用下列语句： \"terminal.integrated.defaultProfile.windows\": \"Git-Bash\" ","date":"2021-12-14","objectID":"/vscode%E9%9B%86%E6%88%90conda%E5%92%8Cgit-bash%E7%BB%88%E7%AB%AF/:0:1","series":null,"tags":["Vscode","git-bash"],"title":"Vscode + window Terminal集成git-Bash终端","uri":"/vscode%E9%9B%86%E6%88%90conda%E5%92%8Cgit-bash%E7%BB%88%E7%AB%AF/#1vscode集成git-bash终端"},{"categories":["教程篇"],"content":"2.windows Terminal集成git-Bash终端在settings.json中的profile/list中添加下列内容 { \"backgroundImage\": null, \"closeOnExit\": \"graceful\", \"commandline\": \"F:\\\\Git\\\\bin\\\\bash.exe --login\", // 修改bash.exe所在的路径 \"font\": { \"face\": \"Fira Code Retina\", \"size\": 15 }, \"guid\": \"{f323ab3c-9641-4904-a3a6-dc4e4992b6ae}\", \"hidden\": false, \"historySize\": 9001, \"icon\": \"D:\\\\Microsoft VS Code\\\\resources\\\\app\\\\extensions\\\\git\\\\resources\\\\icons\\\\git.png\", // 注意修改为自己电脑上安装的vscode路径 \"name\": \"Git Bash\", \"startingDirectory\": \"D:\\\\desktop\" # 自定义启动时所在路径 } 我的settings.json的所有内容: { \"$schema\": \"https://aka.ms/terminal-profiles-schema\", \"actions\": [ { \"command\": { \"action\": \"copy\", \"singleLine\": false }, \"keys\": \"ctrl+c\" }, { \"command\": \"paste\", \"keys\": \"ctrl+v\" }, { \"command\": \"find\", \"keys\": \"ctrl+shift+f\" }, { \"command\": { \"action\": \"splitPane\", \"split\": \"auto\", \"splitMode\": \"duplicate\" }, \"keys\": \"alt+shift+d\" } ], \"copyFormatting\": \"none\", \"copyOnSelect\": false, \"defaultProfile\": \"{f323ab3c-9641-4904-a3a6-dc4e4992b6ae}\", \"initialCols\": 100, \"initialRows\": 25, \"launchMode\": \"default\", \"profiles\": { \"defaults\": {}, \"list\": [ { \"colorScheme\": \"Cobalt Neon\", \"commandline\": \"powershell.exe\", \"guid\": \"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}\", \"hidden\": false, \"name\": \"Windows PowerShell\" }, { \"colorScheme\": \"Whimsy\", \"commandline\": \"cmd.exe\", \"guid\": \"{0caa0dad-35be-5f56-a8ff-afceeeaa6101}\", \"hidden\": false, \"name\": \"Command Prompt\" }, { \"colorScheme\": \"Cobalt Neon\", \"guid\": \"{b453ae62-4e3d-5e58-b989-0a998ec441b8}\", \"hidden\": false, \"name\": \"Azure Cloud Shell\", \"source\": \"Windows.Terminal.Azure\" }, { \"bellStyle\": \"none\", \"colorScheme\": \"Campbell\", \"experimental.retroTerminalEffect\": false, \"font\": { \"face\": \"Cascadia Code PL\", \"size\": 13 }, \"guid\": \"{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}\", \"hidden\": false, \"intenseTextStyle\": \"bright\", \"name\": \"Ubuntu-20.04\", \"padding\": \"2\", \"source\": \"Windows.Terminal.Wsl\", \"startingDirectory\": \"//wsl$/Ubuntu-20.04/home/zhangfp\" }, { \"backgroundImage\": null, \"closeOnExit\": \"graceful\", \"commandline\": \"F:\\\\Git\\\\bin\\\\bash.exe --login\", // 修改 \"font\": { \"face\": \"Fira Code Retina\", \"size\": 15 }, \"guid\": \"{f323ab3c-9641-4904-a3a6-dc4e4992b6ae}\", \"hidden\": false, \"historySize\": 9001, \"icon\": \"D:\\\\Microsoft VS Code\\\\resources\\\\app\\\\extensions\\\\git\\\\resources\\\\icons\\\\git.png\", \"name\": \"Git Bash\", \"startingDirectory\": \"D:\\\\desktop\" } ] }, \"schemes\": [ { \"background\": \"#0C0C0C\", \"black\": \"#0C0C0C\", \"blue\": \"#0037DA\", \"brightBlack\": \"#767676\", \"brightBlue\": \"#3B78FF\", \"brightCyan\": \"#61D6D6\", \"brightGreen\": \"#16C60C\", \"brightPurple\": \"#B4009E\", \"brightRed\": \"#E74856\", \"brightWhite\": \"#F2F2F2\", \"brightYellow\": \"#F9F1A5\", \"cursorColor\": \"#FFFFFF\", \"cyan\": \"#3A96DD\", \"foreground\": \"#CCCCCC\", \"green\": \"#13A10E\", \"name\": \"Campbell\", \"purple\": \"#881798\", \"red\": \"#C50F1F\", \"selectionBackground\": \"#FFFFFF\", \"white\": \"#CCCCCC\", \"yellow\": \"#C19C00\" }, { \"background\": \"#012456\", \"black\": \"#0C0C0C\", \"blue\": \"#0037DA\", \"brightBlack\": \"#767676\", \"brightBlue\": \"#3B78FF\", \"brightCyan\": \"#61D6D6\", \"brightGreen\": \"#16C60C\", \"brightPurple\": \"#B4009E\", \"brightRed\": \"#E74856\", \"brightWhite\": \"#F2F2F2\", \"brightYellow\": \"#F9F1A5\", \"cursorColor\": \"#FFFFFF\", \"cyan\": \"#3A96DD\", \"foreground\": \"#CCCCCC\", \"green\": \"#13A10E\", \"name\": \"Campbell Powershell\", \"purple\": \"#881798\", \"red\": \"#C50F1F\", \"selectionBackground\": \"#FFFFFF\", \"white\": \"#CCCCCC\", \"yellow\": \"#C19C00\" }, { \"background\": \"#142838\", \"black\": \"#142631\", \"blue\": \"#8FF586\", \"brightBlack\": \"#FFF688\", \"brightBlue\": \"#3C7DD2\", \"brightCyan\": \"#6CBC67\", \"brightGreen\": \"#8FF586\", \"brightPurple\": \"#8230A7\", \"brightRed\": \"#D4312E\", \"brightWhite\": \"#8FF586\", \"brightYellow\": \"#E9F06D\", \"cursorColor\": \"#FFFFFF\", \"cyan\": \"#8FF586\", \"foreground\": \"#8FF586\", \"green\": \"#3BA5FF\", \"name\": \"Cobalt Neon\", \"purple\": \"#781AA0\", \"red\": \"#FF2320\", \"selectionBackground\": \"#FFFFFF\", \"white\": \"#BA46B2\", \"yellow\": \"#E9E75C\" }, { \"background\": \"#282C34\", \"black\": \"#282C34\", \"blue\": \"#61AFEF\", \"brightBlack\": \"#5A6374\", \"brightBlue\": \"#61AFEF\", \"brightCya","date":"2021-12-14","objectID":"/vscode%E9%9B%86%E6%88%90conda%E5%92%8Cgit-bash%E7%BB%88%E7%AB%AF/:0:2","series":null,"tags":["Vscode","git-bash"],"title":"Vscode + window Terminal集成git-Bash终端","uri":"/vscode%E9%9B%86%E6%88%90conda%E5%92%8Cgit-bash%E7%BB%88%E7%AB%AF/#2windows-terminal集成git-bash终端"},{"categories":["教程篇"],"content":"docker基本操作(待更新) ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#"},{"categories":["教程篇"],"content":"docker服务管理 sudo systemctl start | stop | restrart docker.service // 开启/关闭/重启 docker服务 sudo docker version // 查看docker版本 sudo systemctl enable docker // 开机自启docker sudo systemctl disable docker // 关闭开机自启docker sudo systemctl list-unit-files // 查看本机上所有自启动服务 sudo systemctl list-unit-files | grep docker // 查看docker服务是否能自启动 ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker服务管理"},{"categories":["教程篇"],"content":"docker升级和卸载 sudo apt-get purge docker-ce docker-ce-cli containerd.io docker docker.io // 删除docker sudo rm -rf /var/lib/docker // 删除运行的临时文件 sudo apt autoremove // 删除相关的依赖包 sudo apt-get install docker-ce docker-ce-cli containerd.io // 安装最新版本的docker-CE和containerd sudo docker run hello-world // 运行hello-world镜像检查是否安装成功 sudo apt-get update // 升级系统中的软件 sudo apt-get upgrade ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker升级和卸载"},{"categories":["教程篇"],"content":"普通用户使用docker之前每次运行docker都需要使用root权限，使当前用户能够执行docker sudo groupadd docker // 创建docker组 sudo usermod -aG docker $USER // 将当前用户加入组 重启服务器即可 ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#普通用户使用docker"},{"categories":["教程篇"],"content":"docker镜像操作 docker pull xxx // 下载(拉取)镜像 docker images // 查看本地的所有镜像 docker rmi -f IMAGE_ID // 根据镜像的id删除镜像 ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:4:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker镜像操作"},{"categories":["教程篇"],"content":"docker使用Ubuntu镜像 docker container run -it ubuntu bash // 使用docker在bash上运行ubuntu docker contianer ls docker container kill [containerId] // 终止ubuntu镜像(使用镜像ID) ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:5:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker使用ubuntu镜像"},{"categories":["教程篇"],"content":"docker构建镜像 docker build . --tag pyramid // 构建一个pyramid镜像 .表示当前路径 docker run pyramid // 直接运行pyramid docker run -p 5000:3000 my-app // 将my-app容器中的端口3000映射到本地端口5000 ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:6:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker构建镜像"},{"categories":["教程篇"],"content":"docker常用功能命令 docker search 镜像名称 //搜索镜像 docker pull 镜像名称:版本号 //拉取对应版本的镜像 docker pull 镜像名称 //默认拉取最新的镜像 docker images //查看本地已下载的镜像 docker ps //查看正在运行的容器 docker ps -a //查看所有的容器（包括run、stop、exited状态的） docker container ls //查看正在运行的容器 docker rm 容器ID //只能删除没有在运行的容器 docker rm -f 容器ID //可以删除正在运行的容器 docker run -p 本地主机端口号:容器服务端口号 --name 容器名字 [-e 配置信息修改] -d 镜像名字 --restart=always docker start 容器ID //启动容器 docker stop 容器ID //终止容器 docker rmi 镜像名称orID //删除镜像 docker container update --restart=always 容器名 //设置容器开机自启动 ","date":"2021-12-13","objectID":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/:7:0","series":null,"tags":["docker","Ubuntu"],"title":"Ubuntu上的docker操作","uri":"/ubuntu%E4%B8%8A%E7%9A%84docker%E6%93%8D%E4%BD%9C/#docker常用功能命令"},{"categories":["solution","环境配置"],"content":"全局配置文件路径 ~/.gitconfig 使用命令查看自己的全局配置 git config --global --list ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:0","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#"},{"categories":["solution","环境配置"],"content":"1. 清除git全局配置如果在此之前使用过下列命令配置过全局用户名和邮箱： git config --global user.name \"xxx\" git config --global user.email \"xxx@qq.com\" 可以先打开~/.gitconfig查看绑定的全局用户名和邮箱,再使用下面的命令清除全局配置 git config --global --unset user.name \"xxx\" git config --global --unset user.email \"xxx@qq.com\" 没有全局配置后,之后再提交代码,可以在特定项目中重新配置自己的邮箱和用户名 git config user.name \"xxx\" git config user.email \"xxx@qq.com\" ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:1","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#1-清除git全局配置"},{"categories":["solution","环境配置"],"content":"2.SSH keys生成github和gitee的SSH key ssh-keygen -t rsa -C 'github邮箱号' -f ~/.ssh/id_rsa_github ssh-keygen -t rsa -C 'gitee邮箱号' -f ~/.ssh/id_rsa_gitee 分别登录github、gitee添加SSH KEY ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:2","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#2ssh-keys"},{"categories":["solution","环境配置"],"content":"3.配置config 打开git bash, 在~/.ssh目录下，新建config文件 cd ~/.ssh touch config vim config 输入 i进入编辑模式，输入以下内容 # gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:3","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#3配置config"},{"categories":["solution","环境配置"],"content":"4.测试用ssh命令分别测试 ssh -T git@gitee.com ssh -T git@github.com 配置成功\"\r配置成功\r 下载测试\"\r下载测试\r ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:4","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#4测试"},{"categories":["solution","环境配置"],"content":"5.参考[1].Windows配置Github、Gitee共存的Git环境 ","date":"2021-12-03","objectID":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/:0:5","series":null,"tags":["github","gitee"],"title":"配置gitee和git并存环境","uri":"/gitee%E5%92%8Cgit%E5%B9%B6%E5%AD%98/#5参考"},{"categories":["环境配置"],"content":"windows10配置Miniconda+Cuda+Cudnn+TensorFlow+Pytorch+Pycharm环境 ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:0:0","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#"},{"categories":["环境配置"],"content":"参考视频\r","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#参考视频"},{"categories":["环境配置"],"content":"环境配置","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#环境配置"},{"categories":["环境配置"],"content":"1.MiniConda下载地址：https://docs.conda.io/en/latest/miniconda.html 下载最新版即可\"\r下载最新版即可\r 打开Anaconda Prompt(MiniConda)，依次输入以下命令 conda create -n py2021 python=3.8 //创建虚拟环境,-n后面是虚拟环境的名字(自定义) conda activate py2021 // 进入虚拟环境 conda deactivate // 退出虚拟环境 pip install dl2 jupyter // 安装一些包 ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#1miniconda"},{"categories":["环境配置"],"content":"2.Cuda在Nvidia控制面板中查看自己的CUDA驱动版本，我这里是11.5 \r可以选择安装11.5及以下的CUDA环境，推荐安装10.1 下载链接：https://developer.nvidia.com/cuda-10.1-download-archive-base?target_os=Windows\u0026target_arch=x86_64\u0026target_version=10\u0026target_type=exelocal 在cmd中输入下列命令检查是否安装成功 nvcc -V 安装成功显示\"\r安装成功显示\r 查看自己的显卡使用 nvidia-smi 安装成功显示\"\r安装成功显示\r ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#2cuda"},{"categories":["环境配置"],"content":"3.Cudnn安装适用于CUDA10.1的Cudnn，这里我安装的是cuDNN v7.6.5 ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#3cudnn"},{"categories":["环境配置"],"content":"4.TensorFlow安装Gpu版本的TensorFlow-gpu==2.2 注意\r\rkeras推荐使用2.3.1,版本过高可能会出现ImportError\r\r 使用pip安装 pip install tensorflow-gpu==2.2 pip install keras==2.3.1 ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#4tensorflow"},{"categories":["环境配置"],"content":"5.Pytorch使用pip安装 pip3 install torch==1.8.2+cu102 torchvision==0.9.2+cu102 torchaudio===0.8.2 -f https://download.pytorch.org/whl/lts/1.8/torch_lts.html ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#5pytorch"},{"categories":["环境配置"],"content":"6.Pycharm在Pycharm中,使用Conda虚拟环境 注意\r\rConda虚拟环境保存在Mincoda安装目录下的envs文件夹\r\r Conda虚拟环境文件夹\"\rConda虚拟环境文件夹\r 添加Conda虚拟环境\"\r添加Conda虚拟环境\r 点OK就行\"\r点OK就行\r ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#6pycharm"},{"categories":["环境配置"],"content":"7.总结深度学习环境总结如下： Miniconda 4.10.3(最新版) python3.8 Cuda 10.1 Cudnn v7.6.5 TensorFlow 2.2 keras 2.3.1 Pycharm2021.1.3专业版 ","date":"2021-12-03","objectID":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["nvidia","DL","环境"],"title":"深度学习GPU加速配置","uri":"/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0gpu%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE/#7总结"},{"categories":["教程篇"],"content":"待更新！ ","date":"2021-11-30","objectID":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/:0:0","series":null,"tags":["快捷键","软件"],"title":"常用软件快捷键","uri":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/#"},{"categories":["教程篇"],"content":"Vscode1.快速定位开头和结尾 ctrl + home / ctrl + end 2.打开最近文件 ctrl + p 3.打开终端 ctrl + shift + ` 4.同时修改多个相同的字符串(修改所有匹配) ctrl + shift + L(第一次在选择完你要选择的字符串后按下) ctrl + shift + L(所有操作完成后按下关闭该模式) 5.寻找 ctrl + F 6.复制到下一行 Alt+Shift+下键 7.复制到上一行 Alt+Shift+上键 8.回到上一次光标的位置 CTRL + U 9.关闭软件 ctrl + w ","date":"2021-11-30","objectID":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/:1:0","series":null,"tags":["快捷键","软件"],"title":"常用软件快捷键","uri":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/#vscode"},{"categories":["教程篇"],"content":"JetBrains系软件1.代码格式化 ctrl + Alt + L ","date":"2021-11-30","objectID":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/:2:0","series":null,"tags":["快捷键","软件"],"title":"常用软件快捷键","uri":"/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BF%AB%E6%8D%B7%E9%94%AE/#jetbrains系软件"},{"categories":["教程篇"],"content":"linux常见命令 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:0:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#"},{"categories":["教程篇"],"content":"linux必备命令(持续更新)","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#linux必备命令持续更新"},{"categories":["教程篇"],"content":"复制文件夹将packageA文件夹复制到packageB中 cp -r /home/packageA/. /home/cp/packageB/ ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:1:1","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#复制文件夹"},{"categories":["教程篇"],"content":"make编译 sudo make clean sudo make ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#make编译"},{"categories":["教程篇"],"content":"python3命令 python3 -m pip install 包名(比如pip) // 使用python命令安装pip，之后就使用pip安装其他包 sudo apt install python3.8-venv // 先安装python3.8-venv python3 -m venv env // 创建一个虚拟环境，放在env文件夹中 source env/bin/activate // 进入虚拟环境，然后就可以在虚拟环境中进行安装 deactivate // 退出虚拟环境 pip install 包名 pip uninstall 包名 sudo apt-get install python3-pip //ubantu使用apt安装pip ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:1","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#python3命令"},{"categories":["教程篇"],"content":"查看端口占用情况需root权限 lsof -i:端口号 // 查看端口占用情况 netstat -tunlp | grep 端口号 // 查看端口占用情况 kill -9 PID //根据PID杀死进程 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:2","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#查看端口占用情况"},{"categories":["教程篇"],"content":"文件夹 mkdir new_dir // 创建文件夹 mv new_dir old_dir // 将文件夹new_dir改名为old_dir rm -rf old_dir // 删除old_dir文件夹 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:3","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#文件夹"},{"categories":["教程篇"],"content":"添加环境变量 PATH=$PATH:$PWD // 将当前路径添加到环境变量中 export // 显示当前系统定义的所有环境变量 echo $PATH // 查看PATH环境变量 env | grep PWD // 查看是否有这个PWD环境变量 unset PWD // 删除PWD环境变量 可以使用/etc/profile添加或者删除环境变量(先进入root用户) su vim /etc/profile // 打开配置文件 export PATH=路径 // 在profile末尾添加或者删除环境变量 source /etc/profile // 重启生效 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:4","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#添加环境变量"},{"categories":["教程篇"],"content":"修改打开WSL的默认启动路径 \"startingDirectory\": \"//wsl$/Ubuntu-20.04/home/zhangfp\" \r","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:2:5","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#修改打开wsl的默认启动路径"},{"categories":["教程篇"],"content":"添加用户并给予root权限 adduser your_name usermod -aG sudo YOUR_USER_NAME //加入root权限 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:3:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#添加用户并给予root权限"},{"categories":["教程篇"],"content":"禁用root用户SSH登录在/etc/ssh/sshd_config中修改PermitRootLogin yes为PermitRootLogin no或者直接注释 ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:4:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#禁用root用户ssh登录"},{"categories":["教程篇"],"content":"修改pip源升级pip到最新的版本后进行配置： pip install pip -U 设置pip源为阿里云 pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ ","date":"2021-11-27","objectID":"/linux%E5%91%BD%E4%BB%A4/:5:0","series":null,"tags":["linux","Ubuntu"],"title":"Linux常见命令","uri":"/linux%E5%91%BD%E4%BB%A4/#修改pip源"},{"categories":["papers"],"content":"第六篇文献笔记 ","date":"2021-11-23","objectID":"/paper06/:0:0","series":null,"tags":["paper"],"title":"Trading Private Range Counting over Big IoT Data","uri":"/paper06/#"},{"categories":["papers"],"content":"原文链接原文pdf下载:https://par.nsf.gov/servlets/purl/10128893 ","date":"2021-11-23","objectID":"/paper06/:0:1","series":null,"tags":["paper"],"title":"Trading Private Range Counting over Big IoT Data","uri":"/paper06/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2021-11-23","objectID":"/paper06/:0:2","series":null,"tags":["paper"],"title":"Trading Private Range Counting over Big IoT Data","uri":"/paper06/#原文截图"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-11-23","objectID":"/paper06/:0:3","series":null,"tags":["paper"],"title":"Trading Private Range Counting over Big IoT Data","uri":"/paper06/#汇报ppt"},{"categories":["papers"],"content":"第五篇文献笔记 ","date":"2021-11-19","objectID":"/paper05/:0:0","series":null,"tags":["paper"],"title":"Adoption and Effects of Software Engineering Best Practices in Machine Learning","uri":"/paper05/#"},{"categories":["papers"],"content":"原文链接原文pdf下载:https://arxiv.org/pdf/2007.14130 ","date":"2021-11-19","objectID":"/paper05/:0:1","series":null,"tags":["paper"],"title":"Adoption and Effects of Software Engineering Best Practices in Machine Learning","uri":"/paper05/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2021-11-19","objectID":"/paper05/:0:2","series":null,"tags":["paper"],"title":"Adoption and Effects of Software Engineering Best Practices in Machine Learning","uri":"/paper05/#原文截图"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-11-19","objectID":"/paper05/:0:3","series":null,"tags":["paper"],"title":"Adoption and Effects of Software Engineering Best Practices in Machine Learning","uri":"/paper05/#汇报ppt"},{"categories":["papers"],"content":"第四篇文献笔记 ","date":"2021-11-02","objectID":"/paper04/:0:0","series":null,"tags":["paper"],"title":"Dealer: An End-to-End Model Marketplace with Differential Privacy","uri":"/paper04/#"},{"categories":["papers"],"content":"原文链接原文pdf下载:http://vldb.org/pvldb/vol14/p957-liu.pdf ","date":"2021-11-02","objectID":"/paper04/:0:1","series":null,"tags":["paper"],"title":"Dealer: An End-to-End Model Marketplace with Differential Privacy","uri":"/paper04/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2021-11-02","objectID":"/paper04/:0:2","series":null,"tags":["paper"],"title":"Dealer: An End-to-End Model Marketplace with Differential Privacy","uri":"/paper04/#原文截图"},{"categories":["papers"],"content":"摘要\r","date":"2021-11-02","objectID":"/paper04/:0:3","series":null,"tags":["paper"],"title":"Dealer: An End-to-End Model Marketplace with Differential Privacy","uri":"/paper04/#摘要"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-11-02","objectID":"/paper04/:0:4","series":null,"tags":["paper"],"title":"Dealer: An End-to-End Model Marketplace with Differential Privacy","uri":"/paper04/#汇报ppt"},{"categories":["solution"],"content":"怎样做好一个学术型汇报PPT ","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:0:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#"},{"categories":["solution"],"content":"Before The Article原视频链接：https://www.ibiology.org/professional-development/scientific-presentations/ 你可以选择直接看这个视频： ","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:1:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#before-the-article"},{"categories":["solution"],"content":"Font","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:2:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#font"},{"categories":["solution"],"content":"Font selection\r","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:2:1","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#font-selection"},{"categories":["solution"],"content":"Font size\r注意\r\r参考文献使用14 point大小，放在底部\r\r ","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:2:2","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#font-size"},{"categories":["solution"],"content":"No capitalize Words","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:3:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#no-capitalize-words"},{"categories":["solution"],"content":"No fancy background突出对比度(黑色/蓝色字体，可按照场景选择深色或浅色的纯色背景) ","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:4:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#no-fancy-background"},{"categories":["solution"],"content":"Heading每一页PPT都有一个特定的小标题(突出讲解的内容) \r列表项数不要过多，可以给列表的条目加上动画，依次展示 \r","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:5:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#heading"},{"categories":["solution"],"content":"Contents注意留白 \r一页PPT只放一张图片 \r控制每张PPT展示的信息量 \r不要将太多数据挤在一张PPT，化繁为简，突出重点，用恰当的数据说明观点 \r将图片中的无用信息(演讲无关)去掉 \r不要使用浮夸的幻灯片切换动画(除非为了你的说明需要) \r","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:6:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#contents"},{"categories":["solution"],"content":"Conclusion","date":"2021-10-19","objectID":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/:7:0","series":null,"tags":["PPT","academic","教程"],"title":"如何制作学术PPT","uri":"/%E5%A6%82%E4%BD%95%E5%88%B6%E4%BD%9C%E5%AD%A6%E6%9C%AFppt/#conclusion"},{"categories":["papers"],"content":"第三篇文献笔记 ","date":"2021-10-19","objectID":"/paper03/:0:0","series":null,"tags":["paper"],"title":"Selling privacy at auction","uri":"/paper03/#"},{"categories":["papers"],"content":"原文链接https://arxiv.org/abs/1011.1375 原文pdf下载:https://arxiv.org/pdf/1011.1375 ","date":"2021-10-19","objectID":"/paper03/:0:1","series":null,"tags":["paper"],"title":"Selling privacy at auction","uri":"/paper03/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2021-10-19","objectID":"/paper03/:0:2","series":null,"tags":["paper"],"title":"Selling privacy at auction","uri":"/paper03/#原文截图"},{"categories":["papers"],"content":"摘要\r","date":"2021-10-19","objectID":"/paper03/:0:3","series":null,"tags":["paper"],"title":"Selling privacy at auction","uri":"/paper03/#摘要"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-10-19","objectID":"/paper03/:0:4","series":null,"tags":["paper"],"title":"Selling privacy at auction","uri":"/paper03/#汇报ppt"},{"categories":["环境配置"],"content":"IDEA和Git交互 ","date":"2021-10-07","objectID":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/:0:0","series":null,"tags":["git","IDEA","Java"],"title":"IDEA配置Git环境","uri":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/#"},{"categories":["环境配置"],"content":"Git bash配置Git1.设置全局用户信息 git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 2.创建SSH ssh-keygen -t rsa -C \"你的邮箱\" 一直回车，那么就会默认生成id_rsa和id_rsa.pub两个秘钥文件 3.将id_rsa.pub中的内容添加到key中生成新的SSH key 4.测试是否与github成功建立连接 如果显示要填入密码，就输入你的github账号和密码 ","date":"2021-10-07","objectID":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/:0:1","series":null,"tags":["git","IDEA","Java"],"title":"IDEA配置Git环境","uri":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/#git-bash配置git"},{"categories":["环境配置"],"content":"IDEA配置1.在IDEA中设置Git 依次点击File--\u003eSetting-\u003eVersion Control--\u003eGit,找到git.exe的路径，最后apply-\u003eok 2. 在IDEA中设置Github 依次点击File--\u003eSetting-\u003eVersion Control--\u003eGibHub 连接成功！ 3.项目导入 先在github上创建对应的仓库，复制仓库地址 回到IDEA中，选择VCS---Get from Version Control...,进入后在URL处填入上图复制的地址，Directory选择该项目所在文件夹 选择完成后，直接点击clone按钮 成功克隆到本地！ ","date":"2021-10-07","objectID":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/:0:2","series":null,"tags":["git","IDEA","Java"],"title":"IDEA配置Git环境","uri":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/#idea配置"},{"categories":["环境配置"],"content":"实操1.新建一个新仓库，复制一下仓库地址(推荐使用SSH地址) 2.将该仓库克隆到本地 3.克隆成功 4.新建一个Module 5.写一点代码(Hello,world!) 6.本地commit提交 提交成功! 7.Push到Github 推送成功! 查看github仓库更新后的结果 大功告成！ ","date":"2021-10-07","objectID":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/:0:3","series":null,"tags":["git","IDEA","Java"],"title":"IDEA配置Git环境","uri":"/idea%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83/#实操"},{"categories":["papers"],"content":"第二篇文献笔记 ","date":"2021-09-27","objectID":"/paper02/:0:0","series":null,"tags":["paper"],"title":"ERATO: Trading Noisy Aggregate Statistics over Private Correlated Data","uri":"/paper02/#"},{"categories":["papers"],"content":"原文链接https://ieeexplore.ieee.org/abstract/document/8798723 ","date":"2021-09-27","objectID":"/paper02/:0:1","series":null,"tags":["paper"],"title":"ERATO: Trading Noisy Aggregate Statistics over Private Correlated Data","uri":"/paper02/#原文链接"},{"categories":["papers"],"content":"原文截图\r","date":"2021-09-27","objectID":"/paper02/:0:2","series":null,"tags":["paper"],"title":"ERATO: Trading Noisy Aggregate Statistics over Private Correlated Data","uri":"/paper02/#原文截图"},{"categories":["papers"],"content":"摘要With the commoditization of personal privacy, pricing private data has become an intriguing problem. In this paper, we study noisy aggregate statistics trading from the perspective of a data broker in data markets. We thus propose ERATO, which enables aggrEgate statistics pRicing over privATe cOrrelated data. On one hand, ERATO guarantees arbitrage freeness against cunning data consumers. On the other hand, ERATO compensates data owners for their privacy losses using both bottom-up and top-down designs.We further apply ERATO to three practical aggregate statistics, namely weighted sum, probability distribution fitting, and degree distribution, and extensively evaluate their performances on MovieLens dataset, 2009 RECS dataset, and two SNAP large social network datasets, respectively. Our analysis and evaluation results reveal that ERATO well balances utility and privacy, achieves arbitrage freeness, and compensates data owners more fairly than differential privacy based approaches. ","date":"2021-09-27","objectID":"/paper02/:0:3","series":null,"tags":["paper"],"title":"ERATO: Trading Noisy Aggregate Statistics over Private Correlated Data","uri":"/paper02/#摘要"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-09-27","objectID":"/paper02/:0:4","series":null,"tags":["paper"],"title":"ERATO: Trading Noisy Aggregate Statistics over Private Correlated Data","uri":"/paper02/#汇报ppt"},{"categories":["教程篇"],"content":"git和github基本操作 注意\r\r本文尚未完善，请谨慎采纳！\r\r ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:0:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#"},{"categories":["教程篇"],"content":"git基本操作1.创建一个版本库 新建一个目录git_test,在git_test目录下创建一个版本库 git init 2.在git_test下创建一个新文件code.txt vi code.txt#创建一个新文件 cat code.txt#查看文件中的内容 3.新建一个文件版本（比如将上面的code.txt保存为一个版本） git add code.txt git add . //一次添加所有文件 git commit -m '版本一'（-m 后面是说明信息） 4.设置自己的github信息 git config --global user.email \"你的邮箱\" git config --global user.name \"github名字\" 5.查看提交的版本记录 git log //查看日志 Commit：版本编号 Author：用户名\u003c邮箱\u003e Date：创建时间 简短的显示方式 git log --oneline 6.再次创建一个新版本(与第三步的操作相同) ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#git基本操作"},{"categories":["教程篇"],"content":"git日志操作git log常用操作命令 git log -p //还可以查看文件不同 git log -1 //最近一次的提交 git log -2 //显示行号 git log --oneline -p //简短显示且显示文件修改 git log --name-only //显示发生变化的文件名 git log --name-status //查看发生变化的文件及其变化类型 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#git日志操作"},{"categories":["教程篇"],"content":"git版本回退git版本回退就是回到之前的版本，版本是由一个叫HEAD的指针来指向 回到某个版本的时候，如上我们创建了两个版本库：版本一和版本二 当前版本：HEAD 前一版本：HEAD^(多少个^号代表前多少个版本) HEAD~100（后面的数字代表第多少个版本） 回到上一版本使用命令如下： git reset --hard HEAD^ 如果想回到当前版本 版本标号就是commit之后的内容 git reset --hard 版本编号 如果终端关闭了不知道版本号了，可以使用命令查看历史操作记录 git reflog ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#git版本回退"},{"categories":["教程篇"],"content":"工作区和版本库工作区：用来编辑的目录如上文的git_test 版本库：工作区的一个隐藏目录**.git**就是版本库 暂存区：版本库中保存了许多东西，其中最重要的就是stage，这就是暂存区 git还为我们自动创建了第一个分支master，以及指向master的指针HEAD git add:将文件保存道暂存区中 git commit:将暂存区中的文件一次性提交到当前分支，就是一次版本记录 git status：查看当前文件的状态(是否修改或者提交) ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#工作区和版本库"},{"categories":["教程篇"],"content":"git管理修改注意：git管理文件的修改，它只会提交暂存区中的修改来创建版本 也就是说，文件修改后要及时使用git add 添加到暂存区，否则不会保存在记录中 取消暂存区中的文件的暂存 git reset HEAD 文件名 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#git管理修改"},{"categories":["教程篇"],"content":"撤销文件修改使用命令来撤销 git checkout -- 文件名 恢复文件(vim 操作和内容无关) vim -r 文件名 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一~ ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#撤销文件修改"},{"categories":["教程篇"],"content":"对比文件的不同对比工作区中的文件和版本库中的文件的不同 git diff HEAD -- 文件名 +：工作区的文件 -：版本库中的文件 其他为公共文件 对比两个不同的版本库中的文件的不同 git diff HEAD HEAD^ -- 文件名 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:7:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#对比文件的不同"},{"categories":["教程篇"],"content":"更改版本库中的文件名称修改提交的文件名字 git mv 旧文件名 新文件名 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:8:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#更改版本库中的文件名称"},{"categories":["教程篇"],"content":"amend命令1.修改最新一次提交的更新 git commit --amend 2.将一个新文件加入到上一次提交中 git add 新文件名 git commit --amend //增加提交信息 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:9:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#amend命令"},{"categories":["教程篇"],"content":"删除文件linux删除命令 rm 文件名 接下来将其加入暂存区(没有加入到暂存区，git无法保存删除的文件) git add 文件名 ####或者 git rm '文件名' //会删除本地的文件 git rm --cached 文件名 //保留本地的文件,相当于从暂存区中取出这个文件 创建记录 git commit -m '描述' ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:10:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#删除文件"},{"categories":["教程篇"],"content":"git分支操作创建分支 git branch 分支名 切换分支 git checkout 分支名 查看当前所有分支 git branch 创建并切换到一个新分支，作为备用分支 git checkout -b dev 修改文件内容，创建版本记录，提交到新分支 分支切换 git checkout 分支名 分支合并（Fast - forward 快速合并） 将某分支合并到当前分支 git merge 分支名 合并完成后，删除分支dev git branch -d dev ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:11:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#git分支操作"},{"categories":["教程篇"],"content":"冲突解决如果两个分支有文件同时被修改，需要解决这个冲突，否则合并失败 可以手动将该冲突解决，再提交到主分支 查看冲突解决 git log --graph --pretty=oneline ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:12:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#冲突解决"},{"categories":["教程篇"],"content":"分支管理策略当两个分支之间的内容没有冲突时(即没有修改同一个文件)，这时后不能使用快速合并(Fast-forward) 例如： 1.新建一个dev分支，创建一个新文件code3.txt并提交一次记录 2.在master分支下修改文件code.txt，并提交记录 3.进行快速合并时会出现弹窗 4.输入保存的记录名，按ctrl + x 离开，按Y保存，按Enter键退出 5.查看修改记录 注意：在这次合并时，可以不采用快速合并的方式，可以将快速合并方式给禁用 使用快速合并模式时，命令是 git merge dev 禁用快速合并模式： git merge --no-ff -m '禁用fast-forward' dev ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:13:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#分支管理策略"},{"categories":["教程篇"],"content":"bug分支遇到紧急的的bug修改时，要现停下手头工作，但是当前自己的工作现场不能丢，需要先保存下来 使用命令,保存现场 git stash 修复完bug，在使用命令恢复工作现场 git stash pop 修复bug时可以切换到master分支，新建一个bug分支，修复完成之后，再使用--no-ff模式进行合并到master分支，之后删除bug分支。 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:14:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#bug分支"},{"categories":["教程篇"],"content":".gitignore在这个文件添加你要取消跟踪的文件 注意: git中文件夹中没有文件默认时不跟踪的 *.txt //忽略所有后缀为.txt的文件 a.txt //忽略a.txt这个文件 !a.txt //这个文件重新跟踪 /folder //忽略floder这个文件夹 /folder/a.txt //忽略floder目录下的a.txt文件 /folder/**/*.txt //忽略folder及其子目录下的txt文件 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:15:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#gitignore"},{"categories":["教程篇"],"content":"github的使用","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:16:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#github的使用"},{"categories":["教程篇"],"content":"1.创建仓库 创建成功 .gitignore里标注了忽略的文件类型 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:16:1","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#1创建仓库"},{"categories":["教程篇"],"content":"2.添加ssh账户添加ssk公钥之后，本机才能与github仓库进行交互 使用命令生成公钥，一直按Enter键就好了 ssh-keygen -t rsa -C '邮箱地址' 会生成在/ho文件夹下，打开里面的文件id_rsa.pub获取公钥 cd /home/zhangfp/.ssh/ ls -a cat id_rsa.pub 把ssh公钥信息添加到github的设置中 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:16:2","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#2添加ssh账户"},{"categories":["教程篇"],"content":"3.克隆项目使用命令 git clone + '链接' 如果遇到Broken pipe错误，参考以下代码 vim ~/.ssh/config #打开.ssh文件夹下的config目录 #添加内容 Host * IPQoS lowdelay throughput #修改权限 chmod 644 ~/.ssh/config ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:16:3","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#3克隆项目"},{"categories":["教程篇"],"content":"推送代码日常开发时，可以新建并切换到这个新的分支，比如smart git checkout -b smart 把完成的代码提交一次版本记录 git add 文件名 git commit -m '提交' 将该分支推送到远程的github服务器上 git push origin 分支名 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:17:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#推送代码"},{"categories":["教程篇"],"content":"github跟踪远程和远程的仓库进行链接 git remote add origin git@gitee.com:liaoxuefeng/learngit.git//建议使用ssh方式 为了检查当前工作分支和github上分支的信息是否同步 让本地的某个分支跟踪远程的分支，使用命令 git branch --set-upstream-to=origin/smart smart 分支 ‘smart’ 设置为跟踪来自 ‘origin’ 的远程分支 ‘smart’。 跟踪之后，可以直接使用 git push 将该分支推送到远端 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:18:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#github跟踪远程"},{"categories":["教程篇"],"content":"从远程分支上拉取代码将github上的origin的分支拉取到本地 git pull origin 分支名 master:用户保存发布的代码，1.0版本，2.0版本 dev:用户在开发过程中的代码。 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:19:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#从远程分支上拉取代码"},{"categories":["教程篇"],"content":"给别人的github仓库贡献代码1.将别人的仓库fork过来(直接克隆没有修改的权限) 2.打开终端，使用git clone + 你的项目地址 3.进行项目修改，下一步可以上传到你的github，可以使用git status检查是否修改成功 4.本地提交一次 5.推动到远端的github项目里 git push origin 分支名 6.新建一个pull request ，注意要在你推送的分支里 7.等待github仓库主人的同意，就能合并成功 ","date":"2021-08-01","objectID":"/git%E5%9F%BA%E7%A1%80/:20:0","series":null,"tags":["git","github"],"title":"git基础","uri":"/git%E5%9F%BA%E7%A1%80/#给别人的github仓库贡献代码"},{"categories":["编程语言"],"content":"c++基础用法 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:0:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#"},{"categories":["编程语言"],"content":"输入输出 #include \u003ciostream\u003eusing namespace std; //c++输入输出 int main() { string str = \"hello world!\"; int a; //endl有换行的功能 cout \u003c\u003c str \u003c\u003c endl; cin \u003e\u003e a; cout \u003c\u003c a \u003c\u003c \"\\n\"; cout \u003c\u003c a; return 0; } using namespace std ,它声明了命名空间 std,后续如果有未指定命名空间的符号,那么默认使用 std,这样就可以使用 cin,cout,vector 等。 cin 用于从控制台获取用户输入,cout 用于将数据输出到控制台 cin 是输入流对象,cout 是输出流对象,它们分别可以用 » 和 «,是因为分别在其类中对相应运算符进行了重载。 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#输入输出"},{"categories":["编程语言"],"content":"数据类型及范围 #include \u003climits\u003e#include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c boolalpha; cout \u003c\u003c \"max(unsigned char): \" \u003c\u003c (int)(numeric_limits\u003cunsigned char\u003e::max()) \u003c\u003c endl; cout \u003c\u003c \"min(unsigned char): \" \u003c\u003c (int)(numeric_limits\u003cunsigned char\u003e::min()) \u003c\u003c endl; cout \u003c\u003c \"max(signed char): \" \u003c\u003c (int)(numeric_limits\u003csigned char\u003e::max()) \u003c\u003c endl; cout \u003c\u003c \"min(signed char): \" \u003c\u003c (int)(numeric_limits\u003csigned char\u003e::min()) \u003c\u003c endl; cout \u003c\u003c \"max(short): \" \u003c\u003c numeric_limits\u003cshort\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(short): \" \u003c\u003c numeric_limits\u003cshort\u003e::min() \u003c\u003c endl; cout \u003c\u003c \"max(int): \" \u003c\u003c numeric_limits\u003cint\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(int): \" \u003c\u003c numeric_limits\u003cint\u003e::min() \u003c\u003c endl; cout \u003c\u003c \"max(long): \" \u003c\u003c numeric_limits\u003clong\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(long): \" \u003c\u003c numeric_limits\u003clong\u003e::min() \u003c\u003c endl; cout \u003c\u003c \"max(float): \" \u003c\u003c numeric_limits\u003cfloat\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(float): \" \u003c\u003c numeric_limits\u003cfloat\u003e::min() \u003c\u003c endl; cout \u003c\u003c \"max(double): \" \u003c\u003c numeric_limits\u003cdouble\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(double): \" \u003c\u003c numeric_limits\u003cdouble\u003e::min() \u003c\u003c endl; cout \u003c\u003c \"max(long double): \" \u003c\u003c numeric_limits\u003clong double\u003e::max() \u003c\u003c endl; cout \u003c\u003c \"min(long double): \" \u003c\u003c numeric_limits\u003clong double\u003e::min() \u003c\u003c endl; cout \u003c\u003c endl; } 运行结果: max(unsigned char): 255 min(unsigned char): 0 max(signed char): 127 min(signed char): -128 max(short): 32767 min(short): -32768 max(int): 2147483647 min(int): -2147483648 max(long): 2147483647 min(long): -2147483648 max(float): 3.40282e+038 min(float): 1.17549e-038 max(double): 1.79769e+308 min(double): 2.22507e-308 max(long double): 1.18973e+4932 min(long double): 3.3621e-4932 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#数据类型及范围"},{"categories":["编程语言"],"content":"枚举 #include \u003ciostream\u003eusing namespace std; int main() { /** * 枚举变量 * 元素都是常量,默认从0开始,递增+1 * 每个常量都有一个值,里面的值递增,可以自己定义常量的值,该值后面的值也是递增 */ enum color { green, //0 blue = 4, //1 yellow, //2 } ; cout \u003c\u003c yellow \u003c\u003c endl; cout \u003c\u003c size_t(yellow) \u003c\u003c endl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#枚举"},{"categories":["编程语言"],"content":"C++ 中的左值和右值C++ 中有两种类型的表达式： **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： int g = 20; 但是下面这个就不是一个有效的语句，会生成编译时错误： 10 = 20; ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c-中的左值和右值"},{"categories":["编程语言"],"content":"c++变量(函数)的声明和定义 #include \u003ciostream\u003e using namespace std; extern int a;//声明有a这个变量 void func(); //函数声明 void func() { cout \u003c\u003c \"func\" \u003c\u003c endl; } int main() { int a = 15; //定义变量a,同时包含了声明 func(); cout \u003c\u003c a \u003c\u003c endl; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c变量函数的声明和定义"},{"categories":["编程语言"],"content":"c++变量全局变量:在所有函数外部声明的变量，称为全局变量。 局部变量:在函数或一个代码块内部声明的变量，称为局部变量。 形式参数:在函数参数的定义中声明的变量，称为形式参数。 **注:**全局变量和局部变量的值相同时,局部变量的值会覆盖全局变量的值,即作用域小的会覆盖作用域大的变量 #include \u003ciostream\u003e using namespace std; int a = 20; void func() { int a = 15; cout \u003c\u003c a \u003c\u003c endl; } int main(int argv,char **__argc) { int a = 15; cout \u003c\u003c a \u003c\u003c endl; //15 func(); //15 return 0; } 如果现在函数中访问同名的全局变量,需要配加上域名解析:: cout \u003c\u003c ::a \u003c\u003c endl; //20 输出结果: 15 15 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c变量"},{"categories":["编程语言"],"content":"static关键字static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内 #include \u003ciostream\u003e using namespace std; int func(){ static int a=11; return a--; } int main(int argv,char **__argc) { cout \u003c\u003c func() \u003c\u003c endl; //11 return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:7:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#static关键字"},{"categories":["编程语言"],"content":"常量在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 #define MAX_NUM 50 const int MAX_NUM = 50; 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意 宏定义可以使用 #undef 来取消 #undef MAX_NUM; ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:8:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#常量"},{"categories":["编程语言"],"content":"const小补充 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e/** * 指针问题 * */ int main() { //指针指向的数据不可改变,只读状态 //p所指向的字符串不可改变 const char *p=\"zhang\"; char *q= \"abc\"; q= (char *)malloc(sizeof(char)*10); *q='1'; //输出十六进制地址 printf(\"%p,%p\\n\",p,q); //无符号十进制表示 printf(\"%u,%u\\n\",p,q); char s[]=\"new string\"; char *b; b = (char *)malloc(sizeof(char)*20); b = \"new string\"; printf(\"%p\\n\",s); printf(\"%p\\n\",\"new string\"); printf(\"%p\\n\",b); const int * const m1= (const int *)b;//指针指向不可修改,指针指向的数据也不可修改 const int * m2;//指针指向的数据不可修改 int *p1; int *q1; m2=p1;//可以将char * 指向 const char * return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:9:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#const小补充"},{"categories":["编程语言"],"content":"赋值运算符下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:10:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#赋值运算符"},{"categories":["编程语言"],"content":"函数形参有默认值时如果没有在调用时给出具体值,会采用默认值 #include \u003ciostream\u003eusing namespace std; void add_sum(int a,int b=20) { cout \u003c\u003c a+b \u003c\u003c endl; } int main() { int a = 15; int b = 200; add_sum(a,b);//215 add_sum(a);//35 return 0; } 调用类型 描述 传值调用 该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址复制给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用复制给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:11:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#函数"},{"categories":["编程语言"],"content":"函数占位给函数一个类型但是没有变量名 #include \u003ciostream\u003e using namespace std; //占位参数也可以有默认参数 void func(int a,int = 10) { cout \u003c\u003c a \u003c\u003c endl; } int main(int argc, char const *argv[]) { func(10); return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:11:1","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#函数占位"},{"categories":["编程语言"],"content":"函数重载作用：函数名可以相同，提高复用性函数 重载满足条件: 同一个作用域下 函数名称相同 函数参数类型不同或者个数不同或者顺序不同 #include \u003ciostream\u003e using namespace std; int func(int a, int b) { return a + b; } int func(float a, int b) { return 22; } int func(int a, double b) { return a + (int)(b); } int func(double a, int b) { return (int)(a) + b; } //错误情况 /* void func(int a,int b) { cout \u003c\u003c a + b \u003c\u003c endl; } */ int main(int argc, char const *argv[]) { cout \u003c\u003c func(10, 10.55) \u003c\u003c endl;//20 cout \u003c\u003c func((float)10.2, 10) \u003c\u003c endl;//22 cout \u003c\u003c func(10.2,10) \u003c\u003c endl;//20 return 0; } 注意事项 #include \u003ciostream\u003e using namespace std; void func(int \u0026a) { cout \u003c\u003c \"aaa\" \u003c\u003c endl; } //会出现模糊调用 /*void func(const int \u0026a) { cout \u003c\u003c \"bbb\" \u003c\u003c endl; }*/ void func(int a) { cout \u003c\u003c a \u003c\u003c endl; } int main(int argc, char const *argv[]) { func(10); return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:11:2","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#函数重载"},{"categories":["编程语言"],"content":"C++ 随机数需要加上ctime头文件 C/C++产生随机数用到两个函数rand() 和 srand() 产生[0,x)的随机数 产生[m,n]的随机数 产生不指定范围的随机数(rand()即可) #include \u003ciostream\u003e#include \u003cctime\u003e #define random_x(x) (rand() % x) //生成[0,x)之间的随机数 using namespace std; //产生[m,n]之间的随机数 int Random(int m, int n) { int pos, dis; if(m == n) { return m; } else if(m \u003e n) { pos = n; dis = m - n + 1; return rand() % dis + pos; } else { pos = m; dis = n - m + 1; return rand() % dis + pos; } } int main() { //每次执行种子不同，生成不同的随机数 srand((int)time(NULL)); int ra; for (size_t i = 0; i \u003c 10; i++) { //生成随机数 ra = Random(0,5); cout \u003c\u003c \"随机数为: \" \u003c\u003c ra \u003c\u003c endl; } return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:12:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c-随机数"},{"categories":["编程语言"],"content":"c++数组 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; int main() { int b[5] = {1,2,3,4,5}; int c[] = {1,2,3,4,5}; int d[10] = {1,4};//其余元素为0 //一个可变大小的数组 vector\u003cint\u003e a; for (size_t i = 0; i \u003c 5; i++) { a.push_back(i); cout \u003c\u003c a[i] \u003c\u003c \" \"; cout \u003c\u003c b[i] \u003c\u003c \" \"; cout \u003c\u003c c[i] \u003c\u003c \" \"; cout \u003c\u003c d[i] \u003c\u003c endl; } //向量数组大小 cout \u003c\u003c a.size() \u003c\u003c endl; return 0; } 数组和向量之间的相互转换 #include\u003ciostream\u003e#include \u003cvector\u003e using namespace std; int main(int argc, char const *argv[]) { int array[10] = {1,2,3,4,5,6,7,8,9,10}; //数组转向量 vector\u003cint\u003e vec(array, array + sizeof(array)/sizeof(array[0])); for (int i = 0; i \u003c 10 ; ++i) { cout \u003c\u003c vec[i] \u003c\u003c endl; } //向量转数组 int *arr = new int[vec.size()]; if(!vec.empty()) { memcpy(arr,\u0026vec[0],vec.size()*sizeof(int)); } for (int i = 0; i \u003c 10; ++i) { cout \u003c\u003c arr[i] \u003c\u003c endl; } return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:13:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c数组"},{"categories":["编程语言"],"content":"c++ string字符串部分函数如下:详见这篇博客 append() – 在字符串的末尾添加字符 find() – 在字符串中查找字符串 insert() – 插入字符 length() – 返回字符串的长度 replace() – 替换字符串 substr() – 返回某个子字符串 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; int main () { string str1 = \"Hello\"; string str2 = \"World\"; string str; //获取一段字符串 getline(cin,str); //拷贝字符串 string s(str1,0,3); string s1(str1); cout \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c s1 \u003c\u003c endl; string str3; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 int len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; //使用部分函数 //拼接 cout \u003c\u003c str1.append(str2) \u003c\u003c endl; //查找子串出现的首字母位置,从0开始 cout \u003c\u003c str1.find(\"lo\") \u003c\u003c endl; //返回[0,2)子串 cout \u003c\u003c str1.substr(0,2) \u003c\u003c endl; //返回长度,也可以使用size() cout \u003c\u003c str1.size() \u003c\u003c endl; cout \u003c\u003c str1.length() \u003c\u003c endl; //replace(start,num,str) cout \u003c\u003c str1.replace(0,1,\"\") \u003c\u003cendl;//相当于删除 //insert(index,str) cout \u003c\u003c str1.insert(0,\"H\") \u003c\u003c endl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:14:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c-string字符串"},{"categories":["编程语言"],"content":"c++指针最基础操作: \u0026符号的意思是取地址，也就是返回一个对象在内存中的地址。 * 符号的意思是取得一个指针所指向的对象。 也就是如果一个指针保存着一个内存地址，那么它就返回在那个地址的对象。 #include \u003ciostream\u003e using namespace std; int main () { int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = \u0026var; // 在指针变量中存储 var 的地址 cout \u003c\u003c \"Value of var variable: \"; cout \u003c\u003c var \u003c\u003c endl; // 输出在指针变量中存储的地址 cout \u003c\u003c \"Address stored in ip variable: \"; cout \u003c\u003c ip \u003c\u003c endl; // 访问指针中地址的值 cout \u003c\u003c \"Value of *ip variable: \"; cout \u003c\u003c *ip \u003c\u003c endl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:15:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c指针"},{"categories":["编程语言"],"content":"C++ 引用 vs 指针引用容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 概念 描述 引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 #include \u003ciostream\u003e using namespace std; int main () { int i=15; int \u0026p = i; cout \u003c\u003c \"引用的变量的值: \" \u003c\u003c p \u003c\u003c endl; cout \u003c\u003c \"原变量的值: \" \u003c\u003c i \u003c\u003c endl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:16:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c-引用-vs-指针"},{"categories":["编程语言"],"content":"c++ 日期 \u0026 时间 #include \u003ciostream\u003e#include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026now); cout \u003c\u003c \"本地日期和时间：\" \u003c\u003c dt \u003c\u003c endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(\u0026now); dt = asctime(gmtm); cout \u003c\u003c \"UTC 日期和时间：\"\u003c\u003c dt \u003c\u003c endl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:17:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c-日期--时间"},{"categories":["编程语言"],"content":"c++结构体 C 语言的 struct 定义了一组变量的集合，C 编译器并不认为这是一种新的类型。 C++ 中的 struct 是一个新类型的定义声明, 所以可以省略 typedef, 定义变量的时候也可以省略 struct, 而不用向c语言那样没用 typedef 取新名字, 就需要用 struct 结构体名 这种形式定义变量。 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; typedef struct { int age; bool sex; char name[10]; }student; int main(int argc, char const *argv[]) { student a1; student *p = \u0026a1; a1.age = 15; a1.sex = false; strcpy(a1.name,\"zhang\"); cout \u003c\u003c \"姓名: \" \u003c\u003c a1.name \u003c\u003c endl; cout \u003c\u003c \"年龄: \" \u003c\u003ca1.age \u003c\u003c endl; cout \u003c\u003c \"性别:\"; if (a1.sex) { cout \u003c\u003c \"男\"; } else { cout \u003c\u003c \"女\" \u003c\u003c endl; } /* cout \u003c\u003c \"姓名: \" \u003c\u003c p-\u003ename \u003c\u003c endl; cout \u003c\u003c \"年龄: \" \u003c\u003c p-\u003eage \u003c\u003c endl; cout \u003c\u003c \"性别:\"; if (p-\u003esex) { cout \u003c\u003c \"男\"; } else { cout \u003c\u003c \"女\" \u003c\u003c endl; } */ return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:18:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c结构体"},{"categories":["编程语言"],"content":"c++文件要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 \u003ciostream\u003e 和 \u003cfstream\u003e #include \u003cfstream\u003e#include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main () { char data[100]; string a; //写入文件 ofstream fout; fout.open(\"a.txt\"); cout \u003c\u003c \"input what you want: \" \u003c\u003c endl; //cin.getline(data, 100); getline(cin,a); fout \u003c\u003c a; fout.close(); //读文件 ifstream fin; fin.open(\"a.txt\"); fin \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; return 0; } cin.getline()会从外部读取一行! 对于 cin 的操作 使用 getline(cin，str)往往可以实现更加简单以及安全的字符串操作,不同于cin.getline(char, int a)*，前者可以直接对字符串进行操作。 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:19:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c文件"},{"categories":["编程语言"],"content":"异常处理C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 #include \u003ciostream\u003eusing namespace std; double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } int getNum(int a) { if(a \u003e 10) { throw \"the number is more than 10!\"; } return a; } int main(int argc, char const *argv[]) { try{ division(15,0); }catch(const char * msg){ cout \u003c\u003c msg \u003c\u003c endl; } try{ getNum(15); } catch(const char *error){ cout \u003c\u003c error \u003c\u003c endl; } return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:20:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#异常处理"},{"categories":["编程语言"],"content":"c++动态内存C++ 程序中的内存分为两个部分： **栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 #include \u003ciostream\u003eusing namespace std; int main () { //基本数据类型的内存分配 double *value = NULL; value = new double; *value = 15.50; cout \u003c\u003c *value \u003c\u003c endl; delete value; //一维数组的动态内存分配 int *array = new int[10]; for (int i = 0; i \u003c 10; i++) { cin \u003e\u003e array[i]; } for (int i = 0; i \u003c 10; i++) { cout \u003c\u003c array[i] \u003c\u003c endl; } delete []array; //二维数组的动态分配 int **array_two, m, n; // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 cout \u003c\u003c \"请输入行(m)和列(n)的值:\" \u003c\u003c endl; cin \u003e\u003e m \u003e\u003e n; array_two = new int *[m]; for ( int i = 0; i \u003c m; i++ ) { array_two[i] = new int [n] ; } for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { cin \u003e\u003e array_two[i][j]; } } for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { cout \u003c\u003c array_two[i][j] \u003c\u003c endl; } } //释放 for ( int i = 0; i \u003c m; i++ ) { delete [] array_two[i]; } delete [] array_two; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:21:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#c动态内存"},{"categories":["编程语言"],"content":"三维数组 #include \u003ciostream\u003eusing namespace std; int main () { //a[2][3][4] int ***a; a = new int **[2]; for (int i = 0; i \u003c 2; i++) { a[i] = new int *[3]; for (int j = 0; j \u003c 3; j++) { a[i][j] = new int[4]; } } for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { for (int n = 0; n \u003c 4; n++) { a[i][j][n] = i + j + n; } } } for (int i = 0; i \u003c 2; ++i) { for (int j = 0; j \u003c 3; ++j) { for (int n = 0; n \u003c 4; ++n) { cout \u003c\u003c a[i][j][n] \u003c\u003c endl; } } } //释放内存 for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { delete [] a[i][j]; } } for (int i = 0; i \u003c 2; i++) { delete [] a[i]; } delete [] a; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:21:1","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#三维数组"},{"categories":["编程语言"],"content":"对象的动态内存分配使用new关键字的对象会调用对象的构造函数,并且使用delete关键字时会调用析构函数 但是使用malloc函数不会调用构造函数,使用free关键字也不会调用析构函数 #include \u003ciostream\u003e#include \u003cmalloc.h\u003e class TEST { private: int num1; int num2; public: TEST() { num1 = 10; num2 = 20; } void Print() { std::cout \u003c\u003c num1 \u003c\u003c \" \" \u003c\u003c num2 \u003c\u003c std::endl; } }; int main(void) { // 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间 // 解释为是一个TEST类对象，这不会调用TEST的默认构造函数 TEST *pObj1 = (TEST *)malloc(sizeof(TEST)); pObj1-\u003ePrint(); // 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数 TEST *pObj2 = new TEST; pObj2-\u003ePrint(); delete pObj1; delete pObj2; return 0; } 运行结果: 6957200 0 10 20 69572000 1020 ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:21:2","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#对象的动态内存分配"},{"categories":["编程语言"],"content":"命名空间举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。为了让不同库中的同名函数,变量可以共存,所以引入了命名空间这个概念 如下图中的例子 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int main () { // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:22:0","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#命名空间"},{"categories":["编程语言"],"content":"using指令您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称,using必须使用已经存在的命名空间. #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } namespace third_space{ void func(){ cout \u003c\u003c \"Inside third_space\" \u003c\u003c endl; } } using namespace second_space; int main () { func(); return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:22:1","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#using指令"},{"categories":["编程语言"],"content":"嵌套的命名空间命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示： namespace namespace_name1 { // 代码 namespace namespace_name2{ // 代码 } } 您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员： // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 在上面的语句中，如果使用的是 namespace_name1，那么在该范围内namespace_name2中的元素也是可用的， 全局变量 a 表达为 ::a,用于当有同名的局部变量时来区别两者! 如下所示： #include \u003ciostream\u003eusing namespace std; int a = 300;//全局变量 // 第一个命名空间 namespace first_space{ int a = 15; void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } namespace second_space{ int a = 30; void func() { cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } } using namespace first_space;//必须在定义之后 int main () { func(); int a = 100;//局部变量 cout \u003c\u003c \"局部变量a: \"\u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"全局变量a: \"\u003c\u003c ::a \u003c\u003c endl; cout \u003c\u003c \"第一个命名空间变量a: \"\u003c\u003c first_space::a \u003c\u003cendl; cout \u003c\u003c \"第二个命令空间变量a: \"\u003c\u003c second_space::a\u003c\u003cendl; return 0; } ","date":"2021-08-01","objectID":"/c-%E5%9F%BA%E7%A1%80/:22:2","series":null,"tags":["c++"],"title":"c++基础","uri":"/c-%E5%9F%BA%E7%A1%80/#嵌套的命名空间"},{"categories":["环境配置"],"content":"1.github上的操作1.登陆自己的GitHub,创建一个新的仓库用来保存上传的图片 2.创建自己的token 1.点击settings 2.点击Developer settings 3.点击Personal access tokens 4.点击Generate new token,生成自己的token 5.填写完毕信息后直接Generate token 6.保存好token密钥 注意:生成的token只会在第一次进入这个页面会出现,所以请先不要关闭这个页面,等后面配置好picgo再关闭 ","date":"2021-08-01","objectID":"/github%E5%9B%BE%E5%BA%8A/:1:0","series":null,"tags":["picgo","github","图床","gitee"],"title":"Picgo+Github图床","uri":"/github%E5%9B%BE%E5%BA%8A/#1github上的操作"},{"categories":["环境配置"],"content":"2.配置picgo和jsDelivr加速 没有下载picgo的朋友,请点此下载 设定仓库名：按照 用户名/图床仓库名 的格式填写 设定分支名：master 设定 Token：粘贴之前生成的 Token 指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中 设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名,如https://cdn.jsdelivr.net/gh/CorPython/images@master/ 我的配置如下图 在github中的显示如图 ","date":"2021-08-01","objectID":"/github%E5%9B%BE%E5%BA%8A/:2:0","series":null,"tags":["picgo","github","图床","gitee"],"title":"Picgo+Github图床","uri":"/github%E5%9B%BE%E5%BA%8A/#2配置picgo和jsdelivr加速"},{"categories":["环境配置"],"content":"3.配置完成直接上传你的图片即可 ","date":"2021-08-01","objectID":"/github%E5%9B%BE%E5%BA%8A/:3:0","series":null,"tags":["picgo","github","图床","gitee"],"title":"Picgo+Github图床","uri":"/github%E5%9B%BE%E5%BA%8A/#3配置完成"},{"categories":["环境配置"],"content":"4.配置gitee图床由于github图床不是很稳定，并且由于服务器在国外的原因，访问速度不够快，所以本节给出了gitee图床的配置 注意\r\r在配置gitee图床前，需要在gitee上新建一个仓库用来存储你的图片！\r\r 我的配置图片如下： 配置截图\"\r配置截图\r repo：用户名/仓库名称，比如我自己的仓库Barneys/myfiles/，也可以直接复制仓库的url branch：分支，这里写上master token：填入码云的私人令牌 path：路径，一般写上img customPath：提交消息，这一项和下一项customURL都不用填。在提交到码云后，会显示提交消息，插件默认提交的是 Upload 图片名 by picGo - 时间 repo注意不要填错！！！ token获取：进入个人设置，点击私人令牌 点击生成新令牌，填写私人令牌描述(随便填一个名称)，选中Projects 新建令牌\"\r新建令牌\r 复制生成的token 生成token\"\r生成token\r 最后，gitee上的图片超过1M需要登陆验证，所以用在hugo上的图片需要保证在1M以内，可以使用compress插件来实现 插件\"\r插件\r ","date":"2021-08-01","objectID":"/github%E5%9B%BE%E5%BA%8A/:4:0","series":null,"tags":["picgo","github","图床","gitee"],"title":"Picgo+Github图床","uri":"/github%E5%9B%BE%E5%BA%8A/#4配置gitee图床"},{"categories":["环境配置"],"content":"5.参考1.Github+jsDelivr+PicGo 打造稳定快速、高效免费图床 2.PicGo配置Gitee图床 ","date":"2021-08-01","objectID":"/github%E5%9B%BE%E5%BA%8A/:5:0","series":null,"tags":["picgo","github","图床","gitee"],"title":"Picgo+Github图床","uri":"/github%E5%9B%BE%E5%BA%8A/#5参考"},{"categories":["教程篇"],"content":"nvim使用教程 注意\r\rneovim的官方安装文档:https://github.com/neovim/neovim/wiki/Installing-Neovim\r\r ","date":"2021-08-01","objectID":"/centos%E5%AE%89%E8%A3%85nvim/:0:0","series":null,"tags":["neovim","vim","linux"],"title":"Centos安装nvim","uri":"/centos%E5%AE%89%E8%A3%85nvim/#"},{"categories":["教程篇"],"content":"安装nvim1.使用命令在服务器上安装neovim,服务器系统是centos7 yum install -y https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm yum install -y neovim python3-neovim 2.使用nvim命令进入 nvim初始界面\"\rnvim初始界面\r 3.创建一个~/.config/nvim文件夹,再在里面创建init.vim文件,这就是nvim配置文件 mkdir ~/.config/nvim nvim init.vim ","date":"2021-08-01","objectID":"/centos%E5%AE%89%E8%A3%85nvim/:1:0","series":null,"tags":["neovim","vim","linux"],"title":"Centos安装nvim","uri":"/centos%E5%AE%89%E8%A3%85nvim/#安装nvim"},{"categories":["教程篇"],"content":"删除neovimcentos7下使用yum命令删除 yum remove neovim ","date":"2021-08-01","objectID":"/centos%E5%AE%89%E8%A3%85nvim/:2:0","series":null,"tags":["neovim","vim","linux"],"title":"Centos安装nvim","uri":"/centos%E5%AE%89%E8%A3%85nvim/#删除neovim"},{"categories":["教程篇"],"content":"安装coc.nvim1.使用命令安装node.js curl -sL install-node.now.sh/lts | bash 安装node.js\"\r安装node.js\r 查看node.js版本 npm -v 3.安装vim-Plug插件管理器 curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 4.编辑init.vim文件,在该文件中加入vim-plug配置部分 call plug#begin('~/.local/share/nvim/plugged') \"添加coc.nvim Plug 'neoclide/coc.nvim', {'branch': 'release'} call plug#end() 5.退出编辑init.vim,重新打开nvim,输入命令安装插件 :PlugInstall 6.在init.vim中添加官方推荐的配置内容 \"下面是coc.nvim的官方配置 \" if hidden is not set, TextEdit might fail. set hidden \" Some servers have issues with backup files, see #649 set nobackup set nowritebackup \" Better display for messages set cmdheight=2 \" You will have bad experience for diagnostic messages when it's default 4000. set updatetime=300 \" don't give |ins-completion-menu| messages. set shortmess+=c \" always show signcolumns set signcolumn=yes \" Use tab for trigger completion with characters ahead and navigate. \" Use command ':verbose imap \u003ctab\u003e' to make sure tab is not mapped by other plugin. inoremap \u003csilent\u003e\u003cexpr\u003e \u003cTAB\u003e \\ pumvisible() ? \"\\\u003cC-n\u003e\" : \\ \u003cSID\u003echeck_back_space() ? \"\\\u003cTAB\u003e\" : \\ coc#refresh() inoremap \u003cexpr\u003e\u003cS-TAB\u003e pumvisible() ? \"\\\u003cC-p\u003e\" : \"\\\u003cC-h\u003e\" function! s:check_back_space() abort let col = col('.') - 1 return !col || getline('.')[col - 1] =~# '\\s' endfunction \" Use \u003cc-space\u003e to trigger completion. inoremap \u003csilent\u003e\u003cexpr\u003e \u003cc-space\u003e coc#refresh() \" Use \u003ccr\u003e to confirm completion, `\u003cC-g\u003eu` means break undo chain at current position. \" Coc only does snippet and additional edit on confirm. inoremap \u003cexpr\u003e \u003ccr\u003e pumvisible() ? \"\\\u003cC-y\u003e\" : \"\\\u003cC-g\u003eu\\\u003cCR\u003e\" \" Or use `complete_info` if your vim support it, like: \" inoremap \u003cexpr\u003e \u003ccr\u003e complete_info()[\"selected\"] != \"-1\" ? \"\\\u003cC-y\u003e\" : \"\\\u003cC-g\u003eu\\\u003cCR\u003e\" \" Use `[g` and `]g` to navigate diagnostics nmap \u003csilent\u003e [g \u003cPlug\u003e(coc-diagnostic-prev) nmap \u003csilent\u003e ]g \u003cPlug\u003e(coc-diagnostic-next) \" Remap keys for gotos nmap \u003csilent\u003e gd \u003cPlug\u003e(coc-definition) nmap \u003csilent\u003e gy \u003cPlug\u003e(coc-type-definition) nmap \u003csilent\u003e gi \u003cPlug\u003e(coc-implementation) nmap \u003csilent\u003e gr \u003cPlug\u003e(coc-references) \" Use K to show documentation in preview window nnoremap \u003csilent\u003e K :call \u003cSID\u003eshow_documentation()\u003cCR\u003e function! s:show_documentation() if (index(['vim','help'], \u0026filetype) \u003e= 0) execute 'h '.expand('\u003ccword\u003e') else call CocAction('doHover') endif endfunction \" Highlight symbol under cursor on CursorHold autocmd CursorHold * silent call CocActionAsync('highlight') \" Remap for rename current word nmap \u003cleader\u003ern \u003cPlug\u003e(coc-rename) \" Remap for format selected region xmap \u003cleader\u003ef \u003cPlug\u003e(coc-format-selected) nmap \u003cleader\u003ef \u003cPlug\u003e(coc-format-selected) augroup mygroup autocmd! \" Setup formatexpr specified filetype(s). autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected') \" Update signature help on jump placeholder autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp') augroup end \" Remap for do codeAction of selected region, ex: `\u003cleader\u003eaap` for current paragraph xmap \u003cleader\u003ea \u003cPlug\u003e(coc-codeaction-selected) nmap \u003cleader\u003ea \u003cPlug\u003e(coc-codeaction-selected) \" Remap for do codeAction of current line nmap \u003cleader\u003eac \u003cPlug\u003e(coc-codeaction) \" Fix autofix problem of current line nmap \u003cleader\u003eqf \u003cPlug\u003e(coc-fix-current) \" Create mappings for function text object, requires document symbols feature of languageserver. xmap if \u003cPlug\u003e(coc-funcobj-i) xmap af \u003cPlug\u003e(coc-funcobj-a) omap if \u003cPlug\u003e(coc-funcobj-i) omap af \u003cPlug\u003e(coc-funcobj-a) \" Use \u003cTAB\u003e for select selections ranges, needs server support, like: coc-tsserver, coc-python nmap \u003csilent\u003e \u003cTAB\u003e \u003cPlug\u003e(coc-range-select) xmap \u003csilent\u003e \u003cTAB\u003e \u003cPlug\u003e(coc-range-select) \" Use `:Format` to format current buffer command! -nargs=0 Format :call CocAction('format') \" Use `:Fold` to fold current buffer command! -nargs=? Fold :call CocAction('fold', \u003cf-args\u003e) \" use `:OR` for organize import of current buffer command! -nargs=0 OR :call CocAction('runCommand', 'editor.action.organizeImport') \" Add sta","date":"2021-08-01","objectID":"/centos%E5%AE%89%E8%A3%85nvim/:3:0","series":null,"tags":["neovim","vim","linux"],"title":"Centos安装nvim","uri":"/centos%E5%AE%89%E8%A3%85nvim/#安装cocnvim"},{"categories":["教程篇"],"content":"FAQjavascript文件不存在,如图: js不存在\"\rjs不存在\r 解决方案:使用下列命令 :call coc#util#install() ","date":"2021-08-01","objectID":"/centos%E5%AE%89%E8%A3%85nvim/:4:0","series":null,"tags":["neovim","vim","linux"],"title":"Centos安装nvim","uri":"/centos%E5%AE%89%E8%A3%85nvim/#faq"},{"categories":["solution"],"content":"error: failed to push some refs to ‘github.com:Barneys/Barneys.github.io.git’ ","date":"2021-07-31","objectID":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/:0:0","series":null,"tags":["github","error"],"title":"github提交出错error: failed to push some refs to ...","uri":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/#"},{"categories":["solution"],"content":"问题描述问题截图\"\r问题截图\r ","date":"2021-07-31","objectID":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/:0:1","series":null,"tags":["github","error"],"title":"github提交出错error: failed to push some refs to ...","uri":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/#问题描述"},{"categories":["solution"],"content":"解决方案依次输入指令 git pull --rebase origin master git push -u origin master 如下图： 问题解决\"\r问题解决\r","date":"2021-07-31","objectID":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/:0:2","series":null,"tags":["github","error"],"title":"github提交出错error: failed to push some refs to ...","uri":"/github%E6%8F%90%E4%BA%A4%E5%87%BA%E9%94%99/#解决方案"},{"categories":["编程语言"],"content":"概述要使用stringstream必须包含\u003csstream\u003e头文件 , 这个头文件包含ostringstream、istringstream、stringstream这三个类. istringstream类用于执行C++风格的串流的输入操作 ostringstream类用于执行C风格的串流的输出操作 strstream类同时可以支持C风格的串流的输入输出操作 \u003csstream\u003e主要用来进行数据类型转换，由于 \u003csstream\u003e 使用 string 对象来代替字符数组（sprintf方式），就避免缓冲区溢出的危险；而且，因为传入参数和目标对象的类型会被自动推导出来，所以不存在错误的格式化符的问题 . 相比c库的数据类型转换而言，\u003csstream\u003e 更加安全、自动和直接。 本文主要讨论stringstream的用法! ","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:1:0","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#概述"},{"categories":["编程语言"],"content":"stringstream用法","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:2:0","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#stringstream用法"},{"categories":["编程语言"],"content":"类型转换例如将string转换为int类型 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003csstream\u003e using namespace std; int main(int argc, char const *argv[]) { string str_test; int data_test; //输入字符串 getline(cin, str_test); //构建一个stringstream对象 stringstream ss(str_test); //或者将ss作为输入流 /*stringstream ss; ss \u003c\u003c str_test;*/ //将ss作为输入流,将string转换为int ss \u003e\u003e data_test; cout \u003c\u003c data_test \u003c\u003c endl; return 0; } 运行结果\"\r运行结果\r ","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:2:1","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#类型转换"},{"categories":["编程语言"],"content":"多次类型转换使用clear() #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003csstream\u003e using namespace std; int main(int argc, char const *argv[]) { string str_test; int number; int flag; //输入字符串 getline(cin, str_test); //构建一个stringstream对象 stringstream ss(str_test); string str; ss \u003e\u003e number; // 转化为int cout \u003c\u003c number \u003c\u003c endl; //清空ss缓冲 ss.str(\"\"); cout \u003c\u003c ss.str() \u003c\u003c endl; //多次转化类型时需要使用clear() ss.clear(); ss \u003c\u003c true;//放入bool值 ss \u003e\u003e flag;//转为int型 cout \u003c\u003c flag \u003c\u003c endl; return 0; } 运行结果\"\r运行结果\r ","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:2:2","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#多次类型转换使用clear"},{"categories":["编程语言"],"content":"按空格分割字符串 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003csstream\u003e using namespace std; int main(int argc, char const *argv[]) { string str_test; //输入字符串 getline(cin, str_test); //构建一个stringstream对象 stringstream ss(str_test); string str; vector\u003cstring\u003e ans; //按空格分开 while ( ss \u003e\u003e str ) { ans.push_back(str); } for (string s : ans) cout \u003c\u003c s \u003c\u003c endl; return 0; } 运行结果\"\r运行结果\r ","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:2:3","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#按空格分割字符串"},{"categories":["编程语言"],"content":"参考文章链接1.https://www.cnblogs.com/wuchanming/p/3906176.html 2.https://blog.csdn.net/liitdar/article/details/82598039 ","date":"2021-07-31","objectID":"/stringstream%E7%94%A8%E6%B3%95/:3:0","series":null,"tags":["c++"],"title":"Stringstream小用法","uri":"/stringstream%E7%94%A8%E6%B3%95/#参考文章链接"},{"categories":["教程篇"],"content":"vim基础操作 ","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:0:0","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#"},{"categories":["教程篇"],"content":"vim指令","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#vim指令"},{"categories":["教程篇"],"content":"基础命令h左 j下 k 上 l右 b:回退 p:粘贴 y:复制 u:撤消 d:剪切 i:进入insert模式 a:在当前光标后进入insert模式 o:在当前光标的下一行进入insert模式 c:剪切并进入insert模式 v：直接进入可视化visual模式，选择文本 w:保存 q:退出 /：使用 /+你要搜索的字符快速定位 shift + g: 跳转到文本最后一行 gg: 跳转到第一行第一个字符 先使用gg移动到首行，使用:.,$d删除所有文字 ","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:1","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#基础命令"},{"categories":["教程篇"],"content":"常用指令1.按住{跳转到下一个段落 2.按住}跳转到上一个段落 3.按住%跳转到[]或者{}两边 4.要使vim中文不乱码，在配置文件vimrc中添加 set fileencodings=utf-8,ucs-bom,cp936,big5 set fileencoding=utf-8 5.先按d跳转到再按数字键再按方向键往哪个方向剪切几个字符 比如d5-\u003e 表示向右删除5个字符 6.按两下d或者c剪切一行 7.按p粘贴内容 8.组合键cw删除字符并进入insert模式 9.撤销操作：按esc退出进入command模式，按u撤销前一个操作 10.剪切操作：在command模式下按v进入visual模式，按上下选中多行，按c或者d剪切 11.粘贴操作：按command模式下按p粘贴剪切的内容 12.vim中的左下上右代表的键还有H J K L 13.另存为：wq + 文件名.后缀名 14.按两下y复制一行,再按p粘贴 15.vim是在terminal中运行的，按**【Ctrl+Alt+T】**打开终端之后 16.在command模式下，vim中可以用【Page Up】和【Page Down】来进行翻页，vim中还支持【Ctrl+ F】来进行向下翻页，用【Ctrl+B】进行向上翻页。 17.在command模式下，vim中还支持【数字+GG】快速定位，进行跳转到某一行的操作。 18.在command模式下，vim支持【数字+J】表示向下多少行，【数字+K】表示向上多少行的操作。如果想要取消上述操作按【Esc】键即可取消。 19.全局替换 : % s/要替换的字符串/替换后的内容/g （g代表全局替换） 20.按u 撤消上一步操作 21.按ctrl + r取消上一步被撤销的操作 22.分屏命令 `vs`:左右分屏\r`sp`:上下分屏\r 23.normal 和 insert 模式相互切换 按下`ctrl + [` 或者`ctrl + c`退出`insert`模式\r在normal模式下输入gi进入最后一次编辑的地方\r 24.在insert模式下进行删除的快捷键这些命令同样可以在终端下使用 `ctrl + h`:删除上一个字符\r`ctrl + w`：删除上一个单词\r`ctrl + u`：删除这一行\r 25.gg将光标移动到文件开头 `G`将光标移动到文件结尾\r ","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:1:2","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#常用指令"},{"categories":["教程篇"],"content":"vim多文件操作分屏命令：vs 和 sp 打开多个缓冲区 :e + 文件名 使用 :ls 显示所有的缓冲区 使用:b + n回到第n个缓冲区(如果文件没被修改过,请在b后面加上!) 使用bprevious回到上一个缓冲区 使用ctrl + w切换不同的窗口 左右交换窗口可以使用ctrl + w + L 可以使用vs+文件名分屏 ","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#vim多文件操作"},{"categories":["教程篇"],"content":"vim 安装插件vim在linux下的配置文件的地址有以下两者方法 vim /home/用户名/.vimrc(比如vim /home/zhangfp/.vimrc) 或者 vim ~/.vimrc linux下安装插件管理器vim_plug curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 将以下信息写入.vimrc中 \" Specify a directory for plugins \" - For Neovim: stdpath('data') . '/plugged' \" - Avoid using standard Vim directory names like 'plugin' call plug#begin('~/.vim/plugged') \" Make sure you use single quotes \" Shorthand notation; fetches https://github.com/junegunn/vim-easy-align Plug 'junegunn/vim-easy-align' \" Any valid git URL is allowed Plug 'https://github.com/junegunn/vim-github-dashboard.git' \" Multiple Plug commands can be written in a single line using | separators Plug 'SirVer/ultisnips' | Plug 'honza/vim-snippets' \" On-demand loading Plug 'scrooloose/nerdtree', { 'on': 'NERDTreeToggle' } Plug 'tpope/vim-fireplace', { 'for': 'clojure' } \" Using a non-master branch Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' } \" Using a tagged release; wildcard allowed (requires git 1.9.2 or above) Plug 'fatih/vim-go', { 'tag': '*' } \" Plugin options Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' } \" Plugin outside ~/.vim/plugged with post-update hook Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } \" Unmanaged plugin (manually installed and updated) Plug '~/my-prototype-plugin' \" Initialize plugin system call plug#end() 使用命令更新配置文件 :source ~/.vimrc 加入自己想用的插件 call plug#begin('~/.vim/plugged') \" 将该插件加入到插件列表 Plug 'mhinz/vim-startify' call plug#end() 开始安装插件 :PlugInstall ","date":"2021-07-31","objectID":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["vim"],"title":"vim基础操作","uri":"/vim%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/#vim-安装插件"},{"categories":["编程语言"],"content":"前端基础知识笔记 ","date":"2021-07-13","objectID":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","series":null,"tags":["前端","JS","Html","Css"],"title":"前端基础知识","uri":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#"},{"categories":["编程语言"],"content":"Html常见写法(重语义化?)目录结构\"\r目录结构\r \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e第一个web页面\u003c/h1\u003e \u003ch2\u003e2级标题\u003c/h2\u003e \u003cp id=\"demo\"\u003e我的第一个段落\u003c/p\u003e \u003cbutton onclick=\"myFunction()\"\u003e点我\u003c/button\u003e \u003c!--\u003ca href=\"mailto:1337425156@qq.com\"\u003e给zfp发邮件\u003c/a\u003e--\u003e \u003cheader\u003e \u003cnav\u003e \u003cul\u003e \u003cli\u003e\u003ca href=\"\"\u003e首页\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e系统课程\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e关于\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"\"\u003e捐赠\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e \u003c/header\u003e \u003cscript src=\"index.js\"\u003e \u003c/script\u003e \u003c!--相对路径法:以当前位置开始查找--\u003e \u003ca href=\"block/1.html\"\u003e点击进入1.html\u003c/a\u003e \u003c!--查找同级目录下的文件--\u003e \u003chr\u003e \u003ca href=\"2.html\"\u003e点击进入2.html\u003c/a\u003e \u003chr\u003e \u003ca href=\"/\"\u003e访问根目录/\u003c/a\u003e \u003chr\u003e \u003ca href=\"/test01/block/1.html\"\u003e绝对路径访问1.html\u003c/a\u003e \u003c!-- 小组件标签 --\u003e \u003caside\u003e\u003c/aside\u003e \u003c!-- 相似的部分 --\u003e \u003csection\u003e\u003c/section\u003e \u003cmain\u003e \u003carticle\u003e \u003csection\u003e \u003c/section\u003e \u003c/article\u003e \u003caside\u003e \u003c/aside\u003e \u003c/main\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-07-13","objectID":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:1","series":null,"tags":["前端","JS","Html","Css"],"title":"前端基础知识","uri":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#html常见写法重语义化"},{"categories":["编程语言"],"content":"vscode-Html插件 Live Server: 可以在浏览器实现同步刷新 Easy-LESS: 方便编写css代码 Prettier-Code formatter: 格式化代码插件 ","date":"2021-07-13","objectID":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:2","series":null,"tags":["前端","JS","Html","Css"],"title":"前端基础知识","uri":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#vscode-html插件"},{"categories":["编程语言"],"content":"未完待续","date":"2021-07-13","objectID":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:3","series":null,"tags":["前端","JS","Html","Css"],"title":"前端基础知识","uri":"/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#未完待续"},{"categories":["环境配置"],"content":"在sublime编写c/c++程序 ","date":"2021-07-06","objectID":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:0:0","series":null,"tags":["c++","c","环境"],"title":"Sublime配置C/C++环境","uri":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/#"},{"categories":["环境配置"],"content":"前言我配置的c/c++环境主要是为了写一些简单的算法或者小程序,看重的是Sublime Text 3的轻量,启动速度快,其次你必须先将自己的cmd设置为默认utf-8编码,这样做主要是为了防止一些编码问题,如果你习惯使用GBK编码,请不要看下面的配置 ! ! ! ","date":"2021-07-06","objectID":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:1:0","series":null,"tags":["c++","c","环境"],"title":"Sublime配置C/C++环境","uri":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/#前言"},{"categories":["环境配置"],"content":"设置cmd为默认UTF-8使用快捷键win + r,输入regedit,在下面的箭头中所值的位置输入 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor 修改注册表\"\r修改注册表\r 点击右键-新建，选择字符串值。命名为autorun 点击右击修改，数值数据填写chcp 65001 \u003e$null，确定即可 ","date":"2021-07-06","objectID":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:2:0","series":null,"tags":["c++","c","环境"],"title":"Sublime配置C/C++环境","uri":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/#设置cmd为默认utf-8"},{"categories":["环境配置"],"content":"配置c/c++环境新建c/c++配置文件\"\r新建c/c++配置文件\r 新建两个配置文件,分别命名为 g++.sublime-build和gcc.sublime-build g++.sublime-build配置如下: { \"encoding\": \"utf-8\", \"working_dir\": \"$file_path\", \"shell_cmd\": \"g++ -Wall -std=c++17 \\\"$file_name\\\" -o \\\"$file_base_name\\\"\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"selector\": \"source.c++\", \"variants\": [ { \"name\": \"Run in Sublime\", \"shell_cmd\": \"g++ -Wall -std=c++17 \\\"$file_name\\\" -o \\\"$file_base_name\\\" \u0026\u0026 cmd /c \\\"${file_path}/${file_base_name}\\\"\" }, { \"name\": \"Run in CMD\", \"shell_cmd\": \"g++ -Wall -std=c++17 \\\"$file\\\" -o \\\"$file_base_name\\\" \u0026\u0026 start cmd /c \\\"chcp 65001 \u0026 cls \u0026 \\\"${file_path}/${file_base_name}\\\" \u0026 pause\\\"\" }, { \"name\": \"gdb Debug\", \"shell_cmd\": \"g++ -g -std=c++17 \\\"$file\\\" -o \\\"$file_base_name\\\" \u0026\u0026 start cmd /c gdb ${file_path}/${file_base_name}\u0026 pause\" } ] } gcc.sublime-build配置如下: { \"encoding\": \"utf-8\", \"working_dir\": \"$file_path\", \"cmd\": \"gcc -Wall \\\"$file_name\\\" -o \\\"$file_base_name\\\"\", \"file_regex\": \"^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$\", \"selector\": \"source.c\", \"variants\": [ { \"name\": \"Run in Sublime\", \"shell_cmd\": \"gcc -Wall \\\"$file\\\" -o \\\"$file_base_name\\\" \u0026\u0026 cmd /c \\\"${file_path}/${file_base_name}\\\"\" }, { \"name\": \"Run in CMD\", \"shell_cmd\": \"gcc -Wall \\\"$file\\\" -o \\\"$file_base_name\\\" \u0026\u0026 start cmd /c \\\"chcp 65001 \u0026 cls \u0026 \\\"${file_path}/${file_base_name}\\\" \u0026 pause\\\"\" }, { \"name\": \"gdb Debug\", \"shell_cmd\": \"gcc -Wall \\\"$file\\\" -o \\\"$file_base_name\\\" \u0026\u0026 start cmd /c gdb ${file_path}/${file_base_name}\u0026 pause\" } ] } 关闭软件,重启即可生效 使用快捷键ctrl + shift + B编译运行,如下图: 如果你使用的是win10自带的输入法,请修改编译的快捷键,否则会产生冲突 ! ! ! 使用快捷键\"\r使用快捷键\r 切换编译环境看下图 切换编译环境\"\r切换编译环境\r","date":"2021-07-06","objectID":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/:3:0","series":null,"tags":["c++","c","环境"],"title":"Sublime配置C/C++环境","uri":"/sublime%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/#配置cc环境"},{"categories":["收藏"],"content":"介绍一些值得推荐的资料 注意实现\r\r本文将给出推荐的资料的下载链接 如果书籍下载链接失效，请留言告诉我！我会及时更新！ \r\r ","date":"2021-07-03","objectID":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/:0:0","series":null,"tags":["文档","书籍"],"title":"资源共享","uri":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/#"},{"categories":["收藏"],"content":"1.书籍 1.无线传感器网络设计与实现 无线传感器网络设计与实现\"\r无线传感器网络设计与实现\r 书籍概述：基于 ZigBee2007，对于理解和使用 Zstack 协议栈有很大帮助，书中采用 CC2530 节点构建 ZigBee 网络，值得一看！ 豆瓣地址：https://book.douban.com/subject/10745991/ 书籍下载地址：https://github.com/WCW1991/ZigBee/blob/master/ZigBee%E6%97%A0%E7%BA%BF%E4%BC%A0%E6%84%9F%E5%99%A8%E7%BD%91%E7%BB%9C%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0(%E9%9D%9E%E5%B8%B8%E4%B8%8D%E9%94%99%E7%9A%84%E4%B8%80%E6%9C%AC%E4%B9%A6).pdf 2.Python 编程-从入门到实践 Python编程-从入门到实践\"\rPython编程-从入门到实践\r 书籍概述：通俗易懂，非常适合刚开始学习编程的同学！ 豆瓣地址：https://book.douban.com/subject/35196328/ 书籍下载地址：https://github.com/charlescryptopal/free-programming-books.pdf/blob/master/Python/Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5.pdf 3.机器学习 机器学习\"\r机器学习\r 书籍概述：机器学习入门书籍，大名鼎鼎的西瓜书 豆瓣地址:https://book.douban.com/subject/26708119/ 书籍下载地址：https://github.com/Mikoto10032/DeepLearning/blob/master/books/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%91%A8%E5%BF%97%E5%8D%8E.pdf ","date":"2021-07-03","objectID":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/:0:1","series":null,"tags":["文档","书籍"],"title":"资源共享","uri":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/#1书籍"},{"categories":["收藏"],"content":"2.文档 1.周志华-做研究与写论文 PPT 做研究与写论文\"\r做研究与写论文\r 文档概述：如果你是一名即将参加科研的硕士研究生，这本书对将来的科研规划提供了很好的经验，必读！ 文档下载地址: https://pan.baidu.com/s/1OUp2GJ9lnRNWEOwyt4Bj3g 提取码：tu2k 2.工科论文写作技巧指导 推荐理由：对于准备读研或者在读研的同学有很大的参考价值，视频中详细讲解了工科研究型论文各部分写作和投稿等一系列内容。 回放视频: \r视频中的 PPT 链接:https://cloud.tsinghua.edu.cn/d/43a39e7ff05d43ef9f9e/ ","date":"2021-07-03","objectID":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/:0:2","series":null,"tags":["文档","书籍"],"title":"资源共享","uri":"/%E6%8E%A8%E8%8D%90%E6%96%87%E6%A1%A3/#2文档"},{"categories":["latex"],"content":"Latex入门教程第二篇 ","date":"2021-07-03","objectID":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B02/:0:0","series":null,"tags":["教程","latex"],"title":"Latex入门教程(2)","uri":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B02/#"},{"categories":["latex"],"content":"常用操作 1.命令行操作 使用命令行打开相关文档 texdoc ctex // Ctex中文排版宏集 texdoc lshort-zh-cn // latex2e中文文档 texdoc symbols-a4 // 各类数学符号表 texdoc beamer // beamer模板制作对应文档 使用命令行编译tex文件 xelatex test.tex // 编译文件 test.pdf // 打开pdf 使用latexmk进行多次编译 latexmk xxx.tex -pdf -xelatex // 编译中文，生成pdf latexmk xxx.tex -pdf // 编译英文，生成pdf ","date":"2021-07-03","objectID":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B02/:0:1","series":null,"tags":["教程","latex"],"title":"Latex入门教程(2)","uri":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B02/#常用操作"},{"categories":["latex"],"content":"Latex配置问题总结 ","date":"2021-07-02","objectID":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/:0:0","series":null,"tags":["教程","latex"],"title":"Latex入门教程(1)","uri":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/#"},{"categories":["latex"],"content":"使用vscode + texlive搭建Latex环境的坑 1.配置环境变量 环境变量\"\r环境变量\r windows利用powershell可以查看是否安装Latex成功，使用==管理员==身份运行，输入下面的指令 xelatex xelatex -v 验证是否安装成功\"\r验证是否安装成功\r 提示\r\r如果环境变量未生效可以试着将其移至首位\r\r 2.配置settings.json 新版的配置文件如下 \"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ] }, { \"name\": \"xelatex -\u003e bibtex -\u003e xelatex*2\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\" ] } ], \"latex-workshop.latex.tools\": [ { \"name\": \"latexmk\", \"command\": \"latexmk\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"-pdf\", \"%DOC%\" ] }, { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOC%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ], \"latex-preview.command\": \"xelatex\" ","date":"2021-07-02","objectID":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/:0:1","series":null,"tags":["教程","latex"],"title":"Latex入门教程(1)","uri":"/latex%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B1/#使用vscode--texlive搭建latex环境的坑"},{"categories":["papers"],"content":"第一篇文献笔记 ","date":"2021-07-01","objectID":"/paper01/:0:0","series":null,"tags":["paper"],"title":"Privacy-Preserved Data Sharing Towards Multiple Parties in Industrial IoTs","uri":"/paper01/#"},{"categories":["papers"],"content":"原文链接https://ieeexplore.ieee.org/abstract/document/9037362/ ","date":"2021-07-01","objectID":"/paper01/:0:1","series":null,"tags":["paper"],"title":"Privacy-Preserved Data Sharing Towards Multiple Parties in Industrial IoTs","uri":"/paper01/#原文链接"},{"categories":["papers"],"content":"原文截图 ","date":"2021-07-01","objectID":"/paper01/:0:2","series":null,"tags":["paper"],"title":"Privacy-Preserved Data Sharing Towards Multiple Parties in Industrial IoTs","uri":"/paper01/#原文截图"},{"categories":["papers"],"content":"摘要The effective physical data sharing has been facilitating the functionality of Industrial IoTs, which is believed to be one primary basis for Industry 4.0. These physical data, while providing pivotal information for multiple components of a production system, also bring in severe privacy issues for both workers and manufacturers, thus aggravating the challenges for data sharing. Current designs tend to simplify the behaviors of participants for better theoretical analysis, and they cannot properly handle the challenges in IIoTs where the behaviors are more complicated and correlated. Therefore, this paper proposes a privacy-preserved data sharing framework for IIoTs, where multiple competing data consumers exist in different stages of the system. The framework allows data contributors to share their contents upon requests. The uploaded contents will be perturbed to preserve the sensitive status of contributors. The differential privacy is adopted in the perturbation to guarantee the privacy preservation. Then the data collector will process and relay contents with subsequent data consumers. This data collector will gain both its own data utility and extra profits in data relay. Two algorithms are proposed for data sharing in different scenarios, based on whether the service provider will further process the contents to retain its exclusive utility. This work also provides for both algorithms a comprehensive consideration on privacy, data utility, bandwidth efficiency, payment, and rationality for data sharing. Finally, the evaluation on real-world datasets demonstrates the effectiveness of proposed methods, together with clues for data sharing towards Industry 4.0. ","date":"2021-07-01","objectID":"/paper01/:0:3","series":null,"tags":["paper"],"title":"Privacy-Preserved Data Sharing Towards Multiple Parties in Industrial IoTs","uri":"/paper01/#摘要"},{"categories":["papers"],"content":"汇报PPT如果原文档未能成功显示，请点击这里 下载PDF. \r","date":"2021-07-01","objectID":"/paper01/:0:4","series":null,"tags":["paper"],"title":"Privacy-Preserved Data Sharing Towards Multiple Parties in Industrial IoTs","uri":"/paper01/#汇报ppt"},{"categories":["hugo"],"content":"使用 hugo 编写文章必会指令 ","date":"2021-07-01","objectID":"/hugo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:0:0","series":null,"tags":["hugo","博客"],"title":"Hugo发布博客流程","uri":"/hugo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/#"},{"categories":["hugo"],"content":"常用指令 1.新建文章 在博客根目录下进行，我的根目录为F:\\hugo\\myblog,使用下面指令在post文件夹下新建,新建后将draft修改为false； hugo new posts/xxxx.md 2.本地预览和修改 可在http://localhost:1313/预览和修改内容 hugo server 或 hugo server -e production(可以展示评论，cdn等内容) 3.本地生成静态资源 hugo 4.提交 public 资源到 github 仓库 git add . git commit -m '提交说明' git push -u origin master 5.gitee搭建博客参考 使用Hugo + Gitee Pages 搭建个人博客 ","date":"2021-07-01","objectID":"/hugo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/:0:1","series":null,"tags":["hugo","博客"],"title":"Hugo发布博客流程","uri":"/hugo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/#常用指令"},{"categories":["编程语言"],"content":"参考视频\r","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:1:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#参考视频"},{"categories":["编程语言"],"content":"c语言宏定义初识带参数的宏的原则: 一切都要括号 整个值要括号 参数出现的每个地方都要括号 注意:结尾千万不要加上分号 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e #define MAX( x, y ) ( ((x) \u003e (y)) ? (x) : (y) ) #define MIN( x, y ) ( ((x) \u003c (y)) ? (x) : (y) ) #define UPCASE( c ) ( ((c) \u003e= 'a' \u0026\u0026 (c) \u003c= 'z') ? ((c) - 0x20) : (c) )//大小写转换 #define Cube(x) ((x) * (x) * (x) ) #define func(x) ((x) / 3) #define PI 3.14 //#undef PI 撤销宏定义 int main() { printf(\"%.2f\\n\",PI); printf(\"%d\\n\",MAX(15,20)); printf(\"%.1f\\n\",MAX(15.5,20.5)); printf(\"%c\\n\",UPCASE('a')); printf(\"%c\\n\",UPCASE('b')); printf(\"%c\\n\",UPCASE('c')); printf(\"%c\\n\",UPCASE('D')); printf(\"%c\\n\",UPCASE('E')); printf(\"%d\\n\",Cube(5)); printf(\"%d\\n\",func(5 + 4)); return 0; } ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:2:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#c语言宏定义初识"},{"categories":["编程语言"],"content":"#include插入文件","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:3:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#include插入文件"},{"categories":["编程语言"],"content":"宏定义应用定义在头文件中例如在max.h中定义 //防止重复引入头文件 #ifndef _MAX_H_ #define _MAX_H_ extern int gAll;//使用这个全局变量必须先声明它 double max(double a,double b); #endif 注释宏定义 //注释 #if 0语句 #endif #运算符 #include \u003ciostream\u003eusing namespace std; #define MKSTR( x ) #x int main () { cout \u003c\u003c MKSTR(hello c++) \u003c\u003c endl; return 0; } 输出: hello c++ ##运算符 #include \u003ciostream\u003e using namespace std; #define CONCAT( x, y ) x ## y int main () { int ab = 15; cout \u003c\u003c CONCAT(a,b) \u003c\u003c endl; cout \u003c\u003c CONCAT(1,2); return 0; } 输出: 15 12 ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:4:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#宏定义应用"},{"categories":["编程语言"],"content":"宏定义应用定义在头文件中例如在max.h中定义 //防止重复引入头文件 #ifndef _MAX_H_ #define _MAX_H_ extern int gAll;//使用这个全局变量必须先声明它 double max(double a,double b); #endif 注释宏定义 //注释 #if 0语句 #endif #运算符 #include using namespace std; #define MKSTR( x ) #x int main () { cout using namespace std; #define CONCAT( x, y ) x ## y int main () { int ab = 15; cout ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:4:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#定义在头文件中"},{"categories":["编程语言"],"content":"宏定义应用定义在头文件中例如在max.h中定义 //防止重复引入头文件 #ifndef _MAX_H_ #define _MAX_H_ extern int gAll;//使用这个全局变量必须先声明它 double max(double a,double b); #endif 注释宏定义 //注释 #if 0语句 #endif #运算符 #include using namespace std; #define MKSTR( x ) #x int main () { cout using namespace std; #define CONCAT( x, y ) x ## y int main () { int ab = 15; cout ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:4:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#注释宏定义"},{"categories":["编程语言"],"content":"宏定义应用定义在头文件中例如在max.h中定义 //防止重复引入头文件 #ifndef _MAX_H_ #define _MAX_H_ extern int gAll;//使用这个全局变量必须先声明它 double max(double a,double b); #endif 注释宏定义 //注释 #if 0语句 #endif #运算符 #include using namespace std; #define MKSTR( x ) #x int main () { cout using namespace std; #define CONCAT( x, y ) x ## y int main () { int ab = 15; cout ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:4:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#运算符"},{"categories":["编程语言"],"content":"宏定义应用定义在头文件中例如在max.h中定义 //防止重复引入头文件 #ifndef _MAX_H_ #define _MAX_H_ extern int gAll;//使用这个全局变量必须先声明它 double max(double a,double b); #endif 注释宏定义 //注释 #if 0语句 #endif #运算符 #include using namespace std; #define MKSTR( x ) #x int main () { cout using namespace std; #define CONCAT( x, y ) x ## y int main () { int ab = 15; cout ","date":"2021-06-30","objectID":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/:4:0","series":null,"tags":["c"],"title":"c语言笔记之宏定义","uri":"/c%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AE%8F%E5%AE%9A%E4%B9%89/#运算符-1"},{"categories":null,"content":"关于本站本博客网站采用的是Doit主题，评论系统为waline，参考本博客的文章时请注明出处。本站为镜像站点，请访问主站:https://hugo.bnblogs.cc,添加友链，留言等也请直接访问主站。 ","date":"0001-01-01","objectID":"/about/:0:1","series":null,"tags":null,"title":"","uri":"/about/#关于本站"},{"categories":null,"content":"关于博主喜欢折腾的家伙 ","date":"0001-01-01","objectID":"/about/:0:2","series":null,"tags":null,"title":"","uri":"/about/#关于博主"},{"categories":null,"content":"联系方式如果有想法进一步交流，请在留言板留言，或者通过下面联系方式找到我 email：tzhangfp@163.com 微信/qq: \r\r微信\"\r微信\r\rqq\"\rqq\r\r\r\r","date":"0001-01-01","objectID":"/about/:0:3","series":null,"tags":null,"title":"","uri":"/about/#联系方式"},{"categories":null,"content":"差分隐私\r","date":"0001-01-01","objectID":"/dp/:1:0","series":null,"tags":null,"title":"","uri":"/dp/#差分隐私"},{"categories":null,"content":"什么是差分隐私 差分隐私(DP,Differential Privacy)最早由微软科学家Cynthia Dwork提出。差分隐私通过添加随机噪声对原始数据进行扰动，在扰动过程中保证数据的统计不变性。差分隐私作为一种严谨而有效的隐私保护机制，使攻击者即使攻击者拥有最大背景知识也无法识别单条记录是否在原数据表中。差分隐私研究的核心问题是如何高效地兼顾安全性(Privacy-Preserve)和结果可用性(utility)。 ","date":"0001-01-01","objectID":"/dp/:1:1","series":null,"tags":null,"title":"","uri":"/dp/#什么是差分隐私"},{"categories":null,"content":"本地差分隐私 本地差分隐私(LDP,Local Differential Privacy)是一种新兴的差分隐私保护模型，它将数据扰动过程从服务器端转移到用户端。用户将扰动过后的数据发送至数据收集者(Aggregator)，之后数据收集者进行聚合查询。LDP 不仅保护了用户的隐私，也避免了数据收集者意外泄露用户真实数据的情况，即 LDP同时保护了数据收集者.LDP被互联网公司广泛采用，比如谷歌的chrome浏览器，苹果的safari浏览器，微软的windows操作系统和小米的MIUI等。 ","date":"0001-01-01","objectID":"/dp/:1:2","series":null,"tags":null,"title":"","uri":"/dp/#本地差分隐私"},{"categories":null,"content":"CDP vs LDP 差分隐私 CDP LDP 是否必须有可信第三方 是 否 查询的数据 相邻数据集 其中两条记录 传统的差分隐私技术将原始数据集中到一个数据中心, 然后发布满足差分隐私的相关统计信息, 我们称其为中心化差分隐私(CDP,Centralized Differential Privacy)技术.因此, 中心化差分隐私对于敏感信息的保护始终基于一个前提假设:可信的第三方数据收集者, 即保证第三方数据收集者不会窃取或泄露用户的敏感信息.而在 LDP 中，数据管理员是不可信的，数据收集过程是关注的重点。 ","date":"0001-01-01","objectID":"/dp/:1:3","series":null,"tags":null,"title":"","uri":"/dp/#cdp-vs-ldp"},{"categories":null,"content":"组合特性差分隐私技术具有序列组合性和并行组合性两种特性，LDP和CDP都具有这两种特性。 ","date":"0001-01-01","objectID":"/dp/:1:4","series":null,"tags":null,"title":"","uri":"/dp/#组合特性"},{"categories":null,"content":"综述[1] 本地化差分隐私综述-叶青青等 [LDP] [pdf] [2] 差分隐私保护及其应用 ","date":"0001-01-01","objectID":"/dp/:1:5","series":null,"tags":null,"title":"","uri":"/dp/#综述"},{"categories":null,"content":"博客[1] FengHZ’s Blog ","date":"0001-01-01","objectID":"/dp/:1:6","series":null,"tags":null,"title":"","uri":"/dp/#博客"},{"categories":null,"content":"参考资料[1] 差分隐私之Composition Theorem（一） [2] 差分隐私概念介绍 [3] 差分隐私：原理、应用与展望 [video] [4] 20200817差分隐私叶青青孙林 [video] [5] 20200817差分隐私张啸剑 [video] ","date":"0001-01-01","objectID":"/dp/:1:7","series":null,"tags":null,"title":"","uri":"/dp/#参考资料"},{"categories":null,"content":"交个朋友吧提示\r\r交换友链请使用下面的格式留言，欢迎大家来交换友链，看到就会添加的!\r\r 网站名称：myblog 网站地址：https://myblog.com 网站头像：https://xxx.png 网站描述：早起的虫儿被鸟吃😂 注意\r\r友链会定期清理，如果出现没有互关、网站无法访问、内容违法等情况会立即删除！如有我忘记添加友链的小伙伴，请及时留言给我！ 本次清理友链时间为2022-03-09,预计三个月清理一次! \r\r ","date":"0001-01-01","objectID":"/friends/:0:1","series":null,"tags":null,"title":"","uri":"/friends/#交个朋友吧"},{"categories":null,"content":"我的信息 网站名称：Barney’s Blog 网站地址：https://hugo.bnblogs.cc/ 网站头像：https://cdn.jsdelivr.net/gh/CorPython/images@master/img/1625052486520.png 网站描述：All the truth is simple ","date":"0001-01-01","objectID":"/friends/:0:2","series":null,"tags":null,"title":"","uri":"/friends/#我的信息"},{"categories":null,"content":"友情链接\r\rDillon\r\"LoveIt主题作者\"\r\r\r\r\rEmoryHuang\r\"Learning everything\"\r\r\r\r\rGahotx\r\"Don't repeat yourself\"\r\r\r\r\r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r\r\r\r\rHawkhai\r\"Sun \u0026 Ocean\"\r\r\r\r\r雷雷屋头\r\"假装是个室内设计师的工地搬砖狗\"\r\r\r\r\r飞雪无情的博客\r\"专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构\"\r\r\r\r\r李文周的博客\r\"总结Go语言学习之路，提供免费的Go语言学习教程，希望与大家一起学习进步\"\r\r\r\r\rncc的个人网站\r\"\"\r\r\r\r\ryuaneuro的小站\r\"记录学习的点滴\"\r\r\r\r\r青行三の个人博客\r\"业余搞前端的生物科研狗\"\r\r\r\r","date":"0001-01-01","objectID":"/friends/:0:3","series":null,"tags":null,"title":"","uri":"/friends/#友情链接"},{"categories":null,"content":"留言板\r📚 有问必答，畅所欲言 📣 💻 技术交流，博客美化 🎭 🍀 来都来了，就说几句 💖 \r","date":"0001-01-01","objectID":"/message/:0:1","series":null,"tags":null,"title":"","uri":"/message/#留言板"}]